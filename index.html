<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>Golf Tracker</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xlsx-js-style@1.2.0/dist/xlsx.bundle.js"></script>

<style>
html,body{margin:0;padding:0;height:100%;overflow:hidden;}
body{background:#181818;color:#fff;font-family:system-ui,sans-serif;}
#scoreBar{position:fixed;top:0;left:0;right:0;height:44px;background:#111;display:none;align-items:center;justify-content:center;font-weight:600;z-index:10;}

/* ALL NON-START PAGES: BUTTONS STACK FROM BOTTOM CENTER UP */
.page{
  display:none;
  height:100%;
  padding:50px 16px 70px;
  box-sizing:border-box;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  gap:8px;
  text-align:center;
  overflow-y:auto;
}
.page.active{display:flex;}

/* START PAGE SCROLLS FROM TOP */
#roundPage{
  justify-content:flex-start;
  padding-top:20px;
}

button{width:100%;max-width:320px;height:44px;font-size:15px;border-radius:10px;border:none;font-weight:600;cursor:pointer;white-space:nowrap;color:#fff;-webkit-tap-highlight-color:transparent;}
.selected{box-shadow:0 0 0 3px #ffffffaa;}
.big{height:52px;font-size:16px;}
input{width:100%;max-width:320px;height:44px;background:#222;color:#fff;border-radius:10px;border:none;text-align:center;font-size:16px;box-sizing:border-box;}
.row{display:flex;gap:8px;width:100%;max-width:320px;}
.row button{flex:1;}
.row input{flex:1;min-width:0;}
.input-wrap{position:relative;width:100%;max-width:320px;}
.input-wrap span{position:absolute;right:14px;top:50%;transform:translateY(-50%);color:#aaa;}

.back-wrap{position:fixed;bottom:10px;left:0;right:0;display:flex;justify-content:center;z-index:5;}
.back{background:#555;height:36px;}

.holes9{background:#2e7d32;}
.holes18{background:#1565c0;}
.par3{background:#4fc3f7;}
.par4{background:#66bb6a;}
.par5{background:#ffb74d;}

.hole{background:#424242;}
.green{background:#43a047;outline:2px solid #a5d6a7;}
.green-miss{background:#2e7d32;height:42px;}
.fairway{background:#81c784;}
.bunker{background:#fbc02d;color:#000;}
.rough{background:#1b5e20;}
.recovery{background:#e65100;}
.danger{background:#c62828;}
.water{background:#1565c0;}

.stat{width:100%;max-width:360px;background:#222;padding:8px 12px;border-radius:10px;font-size:14px;box-sizing:border-box;}
.stat.center{text-align:center;}
.stat-split{display:flex;}
.stat-half{flex:1;text-align:center;}
.stat-half.left{border-right:1px solid #333;}
.num{font-weight:700;}
.summary-title{text-decoration:underline;font-size:22px;font-weight:600;margin:0;line-height:1.2;}
.score-summary{font-size:18px;font-weight:600;margin:0;line-height:1.2;}
.round-meta{font-size:14px;opacity:.85;margin:0;line-height:1.2;}
</style>
</head>

<body>

<div id="scoreBar">E through 0</div>

<div id="roundPage" class="page active">
  <div style="font-size:28px;font-weight:800;">Stat Tracker <span style="font-size:11px;color:#666;">v1.7.7</span></div>
  <div style="max-width:320px;font-size:13px;opacity:.85;line-height:1.4;">
    Enter name, date, course name, and # of holes played, The app will ask for the par and yardage of the hole, then ask for where each shot ended up, fairway, water, bunker, etc, and then it will ask for the 2nd shot details, the yardage left to the hole, and where it ended up, until you select green, and hole out with the putt
  </div>
  <input id="playerName" placeholder="Player Name">
  <div class="row">
    <select id="playerHandicap" style="flex:1;height:44px;background:#222;color:#fff;border-radius:10px;border:none;text-align:center;font-size:15px;appearance:none;-webkit-appearance:none;padding:0 10px;">
      <option value="pro">Compare to: Tour Pro</option>
      <option value="0">Compare to: Scratch (0)</option>
      <option value="5">Compare to: 5 Handicap</option>
      <option value="10">Compare to: 10 Handicap</option>
      <option value="15">Compare to: 15 Handicap</option>
      <option value="20">Compare to: 20 Handicap</option>
      <option value="25">Compare to: 25 Handicap</option>
    </select>
    <input id="roundDate" type="date" style="flex:1;">
  </div>
  <input id="courseName" placeholder="Course Name">
  <div class="row">
    <button class="holes9" onclick="highlight(this);selectPresetHoles(9)">9 Holes</button>
    <button class="holes18" onclick="highlight(this);selectPresetHoles(18)">18 Holes</button>
  </div>
  <input id="customHoles" type="number" inputmode="numeric" min="3" max="18" placeholder="Custom # of Holes (3–18)" onfocus="this.select()">
  <button class="holes9" onclick="enterScoring()">CONFIRM</button>
</div>

<div id="parPage" class="page">
  <h3 id="holeHeader">Hole 1</h3>
  <button class="par3" onclick="highlight(this);setPar(3)">PAR 3</button>
  <button class="par4" onclick="highlight(this);setPar(4)">PAR 4</button>
  <button class="par5" onclick="highlight(this);setPar(5)">PAR 5</button>
  <div class="input-wrap"><input id="holeYards" type="number" inputmode="numeric" onfocus="this.select()"><span>yards</span></div>
  <button class="holes9" onclick="startHole()">CONFIRM</button>
  <div class="back-wrap"><button class="back" onclick="goBack()">BACK</button></div>
</div>

<div id="shotPage" class="page">
  <h3>Tee Shot</h3>
  <button class="holes9" onclick="show('liePage')">SELECT LIE</button>
  <div class="back-wrap"><button class="back" onclick="goBack()">BACK</button></div>
</div>

<div id="liePage" class="page">
  <h3 id="lieTitle" style="margin:0 0 8px 0;font-size:16px;">Where did your tee shot end?</h3>
  <button class="hole" onclick="highlight(this);selectLie('HOLE')">HOLE</button>
  <button class="green big" onclick="highlight(this);selectLie('GREEN')">GREEN</button>
  <button class="green-miss" onclick="highlight(this);selectLie('MISSED GREEN')">MISSED AROUND GREEN</button>
  <div class="row">
    <button class="bunker" onclick="highlight(this);selectLie('GS BUNKER')">GS BUNKER</button>
    <button class="bunker" onclick="highlight(this);selectLie('FW BUNKER')">FW BUNKER</button>
  </div>
  <button class="fairway big" onclick="highlight(this);selectLie('FAIRWAY')">FAIRWAY</button>
  <div class="row">
    <button class="rough" onclick="highlight(this);selectLie('LEFT ROUGH')">LEFT ROUGH</button>
    <button class="rough" onclick="highlight(this);selectLie('RIGHT ROUGH')">RIGHT ROUGH</button>
  </div>
  <div class="row">
    <button class="danger" onclick="highlight(this);selectLie('OB')">OB</button>
    <button class="recovery" onclick="highlight(this);selectLie('RECOVERY')">RECOVERY</button>
    <button class="water" onclick="highlight(this);selectLie('WATER')">WATER</button>
  </div>
  <div class="back-wrap"><button class="back" onclick="goBack()">BACK</button></div>
</div>

<div id="distancePage" class="page">
  <h3 id="distanceTitle">2nd Shot Distance</h3>
  <div class="input-wrap"><input id="shotDistance" type="number" inputmode="numeric" value="100" onfocus="this.select()"><span>yards</span></div>
  <button class="holes9" onclick="confirmDistance()">CONFIRM</button>
  <div class="back-wrap"><button class="back" onclick="goBack()">BACK</button></div>
</div>

<div id="penaltyPage" class="page">
  <h3>Penalty - Water</h3>
  <button class="water" onclick="handlePenalty('drop')">DROP</button>
  <button class="danger" onclick="handlePenalty('rehit')">RE-HIT</button>
  <div class="back-wrap"><button class="back" onclick="goBack()">BACK</button></div>
</div>

<div id="obPenaltyPage" class="page">
  <h3>Penalty - Out of Bounds</h3>
  <button class="danger" onclick="handlePenalty('rehit')">RE-HIT</button>
  <div class="back-wrap"><button class="back" onclick="goBack()">BACK</button></div>
</div>

<div id="recoveryPage" class="page">
  <h3>Recovery - Which direction?</h3>
  <div class="row">
    <button class="rough" onclick="handleRecovery('LEFT')">LEFT</button>
    <button class="rough" onclick="handleRecovery('RIGHT')">RIGHT</button>
  </div>
  <div class="back-wrap"><button class="back" onclick="goBack()">BACK</button></div>
</div>

<div id="missedGreenPage" class="page">
  <h3>Missed Green - Which direction?</h3>
  <div style="display:flex;flex-direction:column;align-items:center;gap:10px;width:100%;max-width:320px;">
    <button class="green-miss" onclick="handleMissedGreen('LONG')">LONG</button>
    <div class="row">
      <button class="green-miss" onclick="handleMissedGreen('LEFT')">LEFT</button>
      <button class="green-miss" onclick="handleMissedGreen('RIGHT')">RIGHT</button>
    </div>
    <button class="green-miss" onclick="handleMissedGreen('SHORT')">SHORT</button>
  </div>
  <div class="back-wrap"><button class="back" onclick="goBack()">BACK</button></div>
</div>

<div id="puttPage" class="page">
  <div id="puttShotNum" style="font-size:14px;opacity:.7;">Shot 3</div>
  <h3 id="puttTitle">Putt 1</h3>
  <div class="input-wrap"><input id="puttDistance" type="number" inputmode="numeric" value="30" onfocus="this.select()" oninput="this.setAttribute('value', this.value)"><span>feet</span></div>
  <button class="holes9" onclick="nextPutt()">CONFIRM PUTT</button>
  <button class="hole" onclick="holeOut()">HOLED IT!</button>
  <div class="back-wrap"><button class="back" onclick="goBack()">BACK</button></div>
</div>

<div id="summaryPage" class="page" style="justify-content:flex-start;padding-top:15px;overflow-y:auto;padding-bottom:20px;">
  <div class="summary-title" style="margin:0;line-height:1;">Round Summary</div>
  <div class="score-summary" style="margin:0;line-height:1.1;">
    <span class="num" id="sumScore"></span>
    (<span class="num" id="sumToPar"></span>)
    Par <span class="num" id="sumPar"></span>
  </div>
  <div class="round-meta" id="roundMeta" style="margin:0 0 8px 0;line-height:1;"></div>

  <div class="stat">
    <div class="stat-split">
      <div class="stat-half left">Avg Score Par 3/4/5</div>
      <div class="stat-half">
        <span class="num" id="avgP3"></span> /
        <span class="num" id="avgP4"></span> /
        <span class="num" id="avgP5"></span>
      </div>
    </div>
  </div>

  <div class="stat center">
    Frwys <span class="num" id="fwHitS"></span>/<span class="num" id="fwOppS"></span>
    (<span class="num" id="fwPctS"></span>%)
    · Left <span class="num" id="fwLeftS"></span>
    (<span class="num" id="fwLeftPctS"></span>%)
    · Right <span class="num" id="fwRightS"></span>
    (<span class="num" id="fwRightPctS"></span>%)
  </div>

  <div class="stat">
    <div class="stat-split">
      <div class="stat-half left">
        GIR- <span class="num" id="girS"></span>/<span class="num" id="girTotS"></span>
        (<span class="num" id="girPctS"></span>%)
      </div>
      <div class="stat-half">
        Prox when GIR- <span class="num" id="proxGirS"></span> ft
      </div>
    </div>
  </div>

  <div class="stat">
    <div class="stat-split">
      <div class="stat-half left">
        Scrambling <span class="num" id="scrS"></span>/<span class="num" id="scrOppS"></span>
        (<span class="num" id="scrPctS"></span>%)
      </div>
      <div class="stat-half">
        Bunkers <span class="num" id="bunS"></span>/<span class="num" id="bunOppS"></span>
        (<span class="num" id="bunPctS"></span>%)
      </div>
    </div>
  </div>

  <div class="stat">
    <div class="stat-split">
      <div class="stat-half left" id="pph"></div>
      <div class="stat-half" id="ppg"></div>
    </div>
  </div>

  <div class="stat">
    <div class="stat-split">
      <div class="stat-half left" id="threePutts"></div>
      <div class="stat-half" id="onePuttPct"></div>
    </div>
  </div>

  <div class="stat center">
    <span style="font-weight:600;">SG: Total</span> <span class="num" id="sgTotal"></span> <span style="font-size:12px;opacity:0.7;">(vs Tour Pro)</span>
  </div>
  
  <div class="stat">
    <div class="stat-split">
      <div class="stat-half left">SG: OTT <span class="num" id="sgOTT">0.00</span></div>
      <div class="stat-half">SG: APP <span class="num" id="sgAPP">0.00</span></div>
    </div>
  </div>
  
  <div class="stat">
    <div class="stat-split">
      <div class="stat-half left">SG: ARG <span class="num" id="sgARG">0.00</span></div>
      <div class="stat-half">SG: Putt <span class="num" id="sgPuttingDisplay"></span></div>
    </div>
  </div>
  
  <div class="row">
    <button class="holes9" onclick="exportToCSV()">SAVE CSV</button>
    <button class="holes18" onclick="exportToExcel()">SAVE EXCEL</button>
  </div>
</div>

<script>
function show(id){
  processingClick=false; // Reset processing flag when changing pages
  document.querySelectorAll('.page').forEach(p=>p.classList.remove('active'));
  document.getElementById(id).classList.add('active');
}
function goBack(){
  const currentPage=document.querySelector('.page.active').id;
  
  // FROM PAR PAGE - Go back to round info OR undo previous hole
  if(currentPage==='parPage'){
    if(currentHole>1&&allHoles.length>0){
      undoLastHole();
    }else{
      show('roundPage');
    }
  }
  
  // FROM LIE PAGE - Go back to par page (first shot) or distance page (later shots)
  else if(currentPage==='liePage'){
    if(shots===1){
      // First shot - reverse stats if counted, then go back to par page
      const currentShot=currentHoleShots[currentHoleShots.length-1];
      if(currentShot){
        // Reverse fairway stats if they were counted
        if(fwCountedThisHole&&currentShot.fwCounted){
          console.log('BACK from lie (shot 1): Reversing fairway stats for: '+currentShot.lie);
          fwOpp--;
          if(currentShot.lie==='FAIRWAY') fwHit--;
          if(currentShot.lie==='LEFT ROUGH') fwLeft--;
          if(currentShot.lie==='RIGHT ROUGH') fwRight--;
          fwCountedThisHole=false;
        }
        // Reverse bunker stats if they were counted
        if(currentShot.bunkerCounted){
          console.log('BACK from lie (shot 1): Reversing bunker opp');
          bunOpp--;
        }
      }
      // Remove the shot - startHole will create a fresh one
      if(currentHoleShots.length>0) currentHoleShots.pop();
      show('parPage');
    }else{
      // Not first shot - go back to previous distance entry
      if(currentHoleShots.length>0) currentHoleShots.pop();
      shots--;
      distanceTitle.innerText=`${ordinal(shots)} Shot Distance`;
      shotDistance.value=currentHoleShots[currentHoleShots.length-1].distanceAfter||100;
      show('distancePage');
    }
  }
  
  // FROM DISTANCE PAGE - Go back to lie selection for same shot
  else if(currentPage==='distancePage'){
    // Remove the next shot that was created when we selected a lie
    if(currentHoleShots.length>shots){
      currentHoleShots.pop();
    }
    shots--;
    
    // Reverse the stats
    const currentShot=currentHoleShots[currentHoleShots.length-1];
    if(currentShot){
      // Reverse fairway stats if they were counted
      if(fwCountedThisHole&&currentShot.fwCounted){
        console.log('BACK: Reversing fairway stats for: '+currentShot.lie);
        fwOpp--;
        if(currentShot.lie==='FAIRWAY') fwHit--;
        if(currentShot.lie==='LEFT ROUGH') fwLeft--;
        if(currentShot.lie==='RIGHT ROUGH') fwRight--;
        fwCountedThisHole=false;
        currentShot.fwCounted=false;
        console.log('BACK: fwOpp='+fwOpp+', fwCountedThisHole=false');
      }
      // Reverse bunker stats if they were counted
      if(currentShot.bunkerCounted){
        console.log('BACK: Reversing bunker opp! bunOpp before: '+bunOpp);
        bunOpp--;
        currentShot.bunkerCounted=false;
        console.log('BACK: bunOpp after: '+bunOpp);
      }
    }
    
    lieTitle.innerText=`Where did your ${ordinal(shots)} shot end?`;
    show('liePage');
  }
  
  // FROM PENALTY PAGES - Go back to lie page
  else if(currentPage==='penaltyPage'||currentPage==='obPenaltyPage'||currentPage==='recoveryPage'||currentPage==='missedGreenPage'){
    show('liePage');
  }
  
  // FROM PUTT PAGE - Go back to lie page of last regular shot
  else if(currentPage==='puttPage'){
    // Just remove the putt and go back - don't touch girThisHole
    if(currentHoleShots.length>0) currentHoleShots.pop();
    lieTitle.innerText=`Where did your ${ordinal(shots)} shot end?`;
    show('liePage');
  }
}

function undoLastHole(){
  // Get the last completed hole from allHoles
  const lastHole=allHoles[allHoles.length-1];
  if(!lastHole) return;
  
  // Remove it from allHoles
  currentHole--;
  allHoles.pop();
  
  const lastScore=lastHole.score;
  
  // Reverse all stats
  totalStrokes-=lastScore;
  totalPar-=lastHole.par;
  totalPutts-=lastHole.putts;
  
  if(lastHole.par===3){c3--;p3-=lastScore;}
  if(lastHole.par===4){c4--;p4-=lastScore;}
  if(lastHole.par===5){c5--;p5-=lastScore;}
  
  // Reverse GIR
  let hadGIR=false;
  let firstPuttDist=0;
  lastHole.shots.forEach(s=>{
    if(s.lie==='GREEN'&&s.shotNum<=(lastHole.par-2)){
      hadGIR=true;
      gir--;
      firstPuttDist=s.distanceAfter||0;
      console.log('UNDO: Reversing GIR. gir is now: '+gir+', removing proximity: '+firstPuttDist);
    }
  });
  if(hadGIR&&firstPuttDist>0){
    console.log('UNDO: girFirstPuttDist before: '+girFirstPuttDist);
    girFirstPuttDist-=firstPuttDist;
    console.log('UNDO: girFirstPuttDist after: '+girFirstPuttDist);
    girPutts-=lastHole.putts;
  }
  
  // Reverse scrambling - check if there was a scrambling opportunity on this hole
  let hadScrambleOpp=false;
  if(!hadGIR){
    // Check if there was a GS bunker or missed GIR situation
    lastHole.shots.forEach(s=>{
      if(s.lie==='GS BUNKER') hadScrambleOpp=true;
    });
    // If they hit green after missing in regulation, that's also a scramble opp
    if(!hadScrambleOpp){
      lastHole.shots.forEach(s=>{
        if(s.lie==='GREEN'&&s.shotNum>(lastHole.par-2)) hadScrambleOpp=true;
      });
    }
    if(hadScrambleOpp){
      scrOpp--;
      if(lastHole.putts===1) scr--;
    }
  }
  
  // Reverse fairway stats
  if(lastHole.par===4||lastHole.par===5){
    const teeShot=lastHole.shots[0];
    if(teeShot){
      fwOpp--;
      if(teeShot.lie==='FAIRWAY') fwHit--;
      if(teeShot.lie==='LEFT ROUGH') fwLeft--;
      if(teeShot.lie==='RIGHT ROUGH') fwRight--;
    }
  }
  
  // Reverse bunker stats
  let hadBunker=false;
  lastHole.shots.forEach(s=>{
    if(s.lie&&s.lie.includes('BUNKER')){
      hadBunker=true;
      bunOpp--;
    }
  });
  if(hadBunker&&lastHole.putts===1) bun--;
  
  // Reverse one-putt stats
  if(lastHole.putts>0){
    onePuttOpp--;
    if(lastHole.putts===1) onePuttMade--;
  }
  
  // Reverse three-putt stats
  if(lastHole.putts>=3) threePlusPutts--;
  
  // Restore hole state
  par=lastHole.par;
  currentHoleData=JSON.parse(JSON.stringify(lastHole));
  currentHoleShots=JSON.parse(JSON.stringify(lastHole.shots));
  shots=lastHole.score-lastHole.putts;
  putts=lastHole.putts-1;
  girThisHole=false; // Always reset so hole can be counted fresh when replayed
  scrCountedThisHole=false;
  firstPuttThisHole=null;
  
  // Remove the holed putt
  currentHoleShots.pop();
  
  // Go to last putt
  puttTitle.innerText=`Putt ${putts+1}`;
  const lastPutt=currentHoleShots[currentHoleShots.length-1];
  const puttInput = document.getElementById('puttDistance');
  puttInput.value = lastPutt.distanceBefore||3;
  puttInput.setAttribute('value', lastPutt.distanceBefore||3);
  holeHeader.innerText=`Hole ${currentHole}`;
  show('puttPage');
}
function highlight(btn){
  btn.parentElement.querySelectorAll('button').forEach(b=>b.classList.remove('selected'));
  btn.classList.add('selected');
}

let totalHoles=null,currentHole=1;
let totalPar=0,totalStrokes=0;
let par=4,shots=0,putts=0;
let fwOpp=0,fwHit=0,fwLeft=0,fwRight=0;
let gir=0,girFirstPuttDist=0;
let girOpp=0,missLeft=0,missRight=0,missShort=0,missLong=0;
let scrOpp=0,scr=0;
let bunOpp=0,bun=0;
let p3=0,p4=0,p5=0,c3=0,c4=0,c5=0;
let firstPuttThisHole=null;
let girThisHole=false;
let fwCountedThisHole=false;
let scrCountedThisHole=false;
let totalPutts=0;
let girPutts=0;
let threePlusPutts=0;
let onePuttOpp=0;
let onePuttMade=0;
let sgPuttingTotal=0;
let sgOTTTotal=0;
let sgAPPTotal=0;
let sgARGTotal=0;

// Strokes Gained Putting lookup table (PGA Tour baseline) - distance in feet
const sgPuttingTable = {
  1:1, 2:1, 3:1.04, 4:1.13, 5:1.23, 6:1.34, 7:1.42, 8:1.51, 9:1.56, 10:1.61,
  11:1.65, 12:1.69, 13:1.72, 14:1.75, 15:1.78, 16:1.81, 17:1.83, 18:1.85, 19:1.86,
  20:1.87, 21:1.88, 22:1.89, 23:1.91, 24:1.92, 25:1.93, 26:1.94, 27:1.95, 28:1.96,
  29:1.97, 30:1.98, 31:1.99, 32:2, 33:2.01, 34:2.01, 35:2.02, 36:2.03, 37:2.04,
  38:2.05, 39:2.05, 40:2.06, 41:2.07, 42:2.08, 43:2.08, 44:2.09, 45:2.1, 46:2.11,
  47:2.12, 48:2.12, 49:2.13, 50:2.14, 55:2.18, 60:2.21, 65:2.25, 70:2.28, 75:2.31,
  80:2.34, 85:2.37, 90:2.4, 100:2.44, 110:2.48
};

// Expected strokes to hole out by lie type and distance (yards) - Tour Pro baseline
// Format: distance -> expected strokes
const sgTeeTable = {
  100:2.92, 105:2.93, 110:2.95, 115:2.97, 120:2.99, 125:2.99, 130:2.97, 135:2.97,
  140:2.97, 145:2.97, 150:2.99, 155:2.99, 160:2.99, 165:3.01, 170:3.02, 175:3.04,
  180:3.05, 185:3.07, 190:3.09, 195:3.11, 200:3.12, 210:3.14, 220:3.17, 230:3.21,
  240:3.25, 250:3.35, 260:3.45, 270:3.55, 280:3.65, 290:3.68, 300:3.71, 320:3.79,
  340:3.86, 360:3.92, 380:3.96, 400:3.99, 420:4.02, 440:4.08, 460:4.17, 480:4.28,
  500:4.41, 520:4.54, 540:4.65, 560:4.74, 580:4.79, 600:4.82
};

const sgFairwayTable = {
  10:2.2, 15:2.3, 20:2.4, 25:2.45, 30:2.5, 35:2.55, 40:2.6, 45:2.62, 50:2.65,
  55:2.67, 60:2.7, 65:2.72, 70:2.73, 75:2.74, 80:2.75, 85:2.77, 90:2.78, 95:2.79,
  100:2.8, 105:2.81, 110:2.83, 115:2.84, 120:2.85, 125:2.86, 130:2.88, 135:2.9,
  140:2.91, 145:2.93, 150:2.95, 155:2.97, 160:2.98, 165:3, 170:3.03, 175:3.06,
  180:3.08, 185:3.11, 190:3.13, 195:3.16, 200:3.19, 210:3.26, 220:3.32, 230:3.39,
  240:3.45, 250:3.52, 260:3.58, 270:3.63, 280:3.69, 290:3.74, 300:3.78
};

const sgRoughTable = {
  10:2.49, 15:2.54, 20:2.59, 25:2.64, 30:2.69, 35:2.74, 40:2.78, 45:2.82, 50:2.85,
  55:2.88, 60:2.91, 65:2.92, 70:2.93, 75:2.95, 80:2.96, 85:2.97, 90:2.99, 95:3.01,
  100:3.02, 105:3.03, 110:3.04, 115:3.06, 120:3.08, 125:3.09, 130:3.11, 135:3.13,
  140:3.15, 145:3.17, 150:3.19, 155:3.21, 160:3.23, 165:3.25, 170:3.27, 175:3.29,
  180:3.31, 185:3.34, 190:3.37, 195:3.4, 200:3.42, 210:3.48, 220:3.53, 230:3.8,
  240:3.64, 250:3.69, 260:3.74, 270:3.78, 280:3.83, 290:3.87, 300:3.9
};

const sgSandTable = {
  10:2.41, 15:2.47, 20:2.53, 25:2.59, 30:2.67, 35:2.76, 40:2.82, 45:2.9, 50:2.98,
  55:3.07, 60:3.15, 65:3.17, 70:3.19, 75:3.22, 80:3.24, 85:3.24, 90:3.23, 95:3.23,
  100:3.23, 105:3.23, 110:3.22, 115:3.21, 120:3.21, 125:3.21, 130:3.21, 135:3.22,
  140:3.22, 145:3.23, 150:3.25, 155:3.26, 160:3.28, 165:3.3, 170:3.33, 175:3.36,
  180:3.4, 185:3.43, 190:3.47, 195:3.51, 200:3.55, 210:3.62, 220:3.7, 230:3.77,
  240:3.84, 250:3.88, 260:3.93, 270:3.96, 280:4, 290:4.02, 300:4.04
};

const sgRecoveryTable = {
  100:3.8, 105:3.8, 110:3.8, 115:3.8, 120:3.78, 125:3.78, 130:3.78, 135:3.78,
  140:3.8, 145:3.8, 150:3.8, 155:3.8, 160:3.81, 165:3.81, 170:3.81, 175:3.81,
  180:3.82, 185:3.83, 190:3.84, 195:3.86, 200:3.87, 210:3.89, 220:3.92, 230:3.95,
  240:3.97, 250:4, 260:4.03, 270:4.07, 280:4.1, 290:4.15, 300:4.2
};

// Handicap adjustment offsets - strokes lost per round compared to tour pro
// These will be used to adjust baseline expectations
const handicapOffsets = {
  'pro': { tee: 0, approach: 0, short: 0, putt: 0 },
  '0': { tee: 1.78, approach: 2.03, short: 0.39, putt: 0.94 },
  '5': { tee: 3.31, approach: 4.29, short: 0.97, putt: 1.42 },
  '10': { tee: 3.61, approach: 6.11, short: 1.33, putt: 2.77 },
  '15': { tee: 4.86, approach: 8.54, short: 4.46, putt: 4.46 },
  '20': { tee: 5.75, approach: 11.26, short: 4.48, putt: 4.48 },
  '25': { tee: 7.53, approach: 14.23, short: 4.71, putt: 4.71 }
};

function getExpectedStrokes(distance, lie){
  let table;
  if(lie === 'TEE') table = sgTeeTable;
  else if(lie === 'FAIRWAY' || lie === 'GREEN') table = sgFairwayTable;
  else if(lie === 'ROUGH' || lie === 'LEFT ROUGH' || lie === 'RIGHT ROUGH' || 
          lie === 'MISS LEFT' || lie === 'MISS RIGHT' || lie === 'MISS SHORT' || lie === 'MISS LONG') table = sgRoughTable;
  else if(lie === 'SAND' || lie === 'GS BUNKER' || lie === 'FW BUNKER') table = sgSandTable;
  else if(lie === 'RECOVERY') table = sgRecoveryTable;
  else table = sgRoughTable; // Default to rough
  
  if(table[distance]) return table[distance];
  
  // Interpolate
  const distances = Object.keys(table).map(Number).sort((a,b)=>a-b);
  if(distance < distances[0]) return table[distances[0]];
  if(distance > distances[distances.length-1]) return table[distances[distances.length-1]];
  
  for(let i=0; i<distances.length-1; i++){
    if(distance > distances[i] && distance < distances[i+1]){
      const d1 = distances[i], d2 = distances[i+1];
      const e1 = table[d1], e2 = table[d2];
      return e1 + (e2-e1) * (distance-d1) / (d2-d1);
    }
  }
  return 3; // Fallback
}

function getExpectedPutts(distance){
  if(distance <= 0) return 0;
  if(sgPuttingTable[distance]) return sgPuttingTable[distance];
  // Interpolate for distances not in table
  const distances = Object.keys(sgPuttingTable).map(Number).sort((a,b)=>a-b);
  for(let i=0; i<distances.length-1; i++){
    if(distance > distances[i] && distance < distances[i+1]){
      const d1 = distances[i], d2 = distances[i+1];
      const e1 = sgPuttingTable[d1], e2 = sgPuttingTable[d2];
      return e1 + (e2-e1) * (distance-d1) / (d2-d1);
    }
  }
  // If beyond 110 ft, extrapolate
  if(distance > 110) return 2.48 + (distance-110) * 0.004;
  return 2;
}

let allHoles=[];
let currentHoleData={};
let currentHoleShots=[];
let processingClick=false;

function selectPresetHoles(n){customHoles.value='';totalHoles=n;}
function enterScoring(){
  const c=parseInt(customHoles.value);
  totalHoles=(c>=3&&c<=18)?c:(totalHoles||9);
  scoreBar.style.display='flex';
  show('parPage');
}
function setPar(p){par=p;holeYards.value=p===3?150:p===4?400:520;}
function startHole(){
  shots=1;
  putts=0;
  firstPuttThisHole=null;
  girThisHole=false;
  fwCountedThisHole=false;
  scrCountedThisHole=false;
  lieTitle.innerText='Where did your tee shot end?';
  currentHoleData={hole:currentHole,par:par,yards:parseInt(holeYards.value)};
  currentHoleShots=[];
  currentHoleShots.push({shotNum:1,lie:null,distanceBefore:currentHoleData.yards,distanceAfter:null,isPutt:false,fwCounted:false,bunkerCounted:false});
  show('liePage');
}
function ordinal(n){return n===1?'1st':n===2?'2nd':n===3?'3rd':`${n}th`;}

function selectLie(lie){
  // Prevent double-clicking
  if(processingClick){
    console.log('Already processing a click, ignoring duplicate');
    return;
  }
  processingClick=true;
  
  const lastShot=currentHoleShots[currentHoleShots.length-1];
  
  // Prevent double-clicking - if lie is already set to this value, ignore
  if(lastShot.lie===lie){
    console.log('Lie already set to '+lie+', ignoring duplicate click');
    processingClick=false;
    return;
  }
  
  // If we're changing the lie, reverse the old stats first
  if(lastShot.lie&&lastShot.lie!==lie){
    console.log('Changing lie from '+lastShot.lie+' to '+lie+', reversing old stats');
    // Reverse fairway stats if they were counted
    if(lastShot.fwCounted){
      console.log('Reversing old fairway stats');
      fwOpp--;
      if(lastShot.lie==='FAIRWAY') fwHit--;
      if(lastShot.lie==='LEFT ROUGH') fwLeft--;
      if(lastShot.lie==='RIGHT ROUGH') fwRight--;
      lastShot.fwCounted=false;
      fwCountedThisHole=false;
    }
    // Reverse bunker stats if they were counted
    if(lastShot.bunkerCounted){
      console.log('Reversing old bunker stats, bunOpp before: '+bunOpp);
      bunOpp--;
      lastShot.bunkerCounted=false;
      console.log('bunOpp after reversal: '+bunOpp);
    }
  }
  
  lastShot.lie=lie;
  
  console.log('Shot #'+shots+', lie='+lie+', fwCountedThisHole='+fwCountedThisHole+', bunkerCounted='+lastShot.bunkerCounted);
  
  // Count fairway stats for tee shots on par 4/5 - only once per hole
  if(shots===1&&(par===4||par===5)&&!fwCountedThisHole){
    console.log('Counting fairway stats for: '+lie);
    fwOpp++;
    if(lie==='FAIRWAY'||lie==='GREEN') fwHit++;  // GREEN counts as hitting fairway
    if(lie==='LEFT ROUGH') fwLeft++;
    if(lie==='RIGHT ROUGH') fwRight++;
    // RECOVERY counts as missing fairway (no fwHit, fwLeft, or fwRight increment)
    fwCountedThisHole=true;
    lastShot.fwCounted=true;
    console.log('fwOpp='+fwOpp+', fwHit='+fwHit+', set fwCountedThisHole=true');
  }else if(shots===1&&(par===4||par===5)&&fwCountedThisHole){
    console.log('Fairway stat already counted for this hole, skipping');
  }
  
  // Count bunker opportunities - only if not already counted
  if((lie==='GS BUNKER'||lie==='FW BUNKER')&&!lastShot.bunkerCounted){
    console.log('Counting bunker opp! bunOpp before: '+bunOpp);
    bunOpp++;
    lastShot.bunkerCounted=true;
    console.log('bunOpp after: '+bunOpp);
  }else if((lie==='GS BUNKER'||lie==='FW BUNKER')&&lastShot.bunkerCounted){
    console.log('Bunker stat already counted for this shot, skipping');
  }
  
  if(lie==='GREEN'){
    putts=0;
    puttTitle.innerText='Putt 1';
    
    // Smart default putt distance based on approach distance
    const approachDist=lastShot.distanceBefore||100;
    let defaultPutt=30;
    if(approachDist<=50) defaultPutt=10;
    else if(approachDist<=75) defaultPutt=15;
    else if(approachDist<=100) defaultPutt=20;
    else if(approachDist<=150) defaultPutt=25;
    else if(approachDist<=200) defaultPutt=30;
    else defaultPutt=40;
    
    lastShot.distanceAfter=defaultPutt;
    
    // Count GIR stats - only once per hole
    console.log('Selecting GREEN - before count: gir='+gir+', girThisHole='+girThisHole);
    if(shots<=par-2){
      if(!girThisHole){
        gir++;
        console.log('Counted GIR! gir is now: '+gir);
      }else{
        console.log('Already counted GIR for this hole, skipping');
      }
      girThisHole=true; // Mark that we hit GIR on this hole
    }else{
      if(!girThisHole && !scrCountedThisHole){
        scrOpp++;
        scrCountedThisHole=true;
        console.log('Not GIR, counted scrambling opp. scrOpp='+scrOpp);
      }
    }
    
    // Only count onePuttOpp if we haven't already
    const hasPuttShot=currentHoleShots.some(s=>s.isPutt);
    if(!hasPuttShot){
      onePuttOpp++;
    }
    
    currentHoleShots.push({shotNum:shots+1,lie:'PUTT',distanceBefore:defaultPutt,distanceAfter:null,isPutt:true,fwCounted:false,bunkerCounted:false});
    const puttInput = document.getElementById('puttDistance');
    puttInput.value = defaultPutt;
    puttInput.setAttribute('value', defaultPutt);
    puttShotNum.innerText=`Shot ${shots+1}`;
    show('puttPage');
    return;
  }
  if(lie==='HOLE'){finishHole();return;}
  if(lie==='WATER'){
    show('penaltyPage');
    return;
  }
  if(lie==='OB'){
    show('obPenaltyPage');
    return;
  }
  if(lie==='RECOVERY'){
    show('recoveryPage');
    return;
  }
  if(lie==='MISSED GREEN'){
    show('missedGreenPage');
    return;
  }
  // Handle green misses - count as missed GIR and scrambling opportunity
  if(lie==='MISS LEFT'||lie==='MISS RIGHT'||lie==='MISS SHORT'||lie==='MISS LONG'){
    lastShot.lie=lie;
    // Count green miss direction
    girOpp++;
    if(lie==='MISS LEFT') missLeft++;
    if(lie==='MISS RIGHT') missRight++;
    if(lie==='MISS SHORT') missShort++;
    if(lie==='MISS LONG') missLong++;
    // Count scrambling opportunity
    if(!girThisHole && !scrCountedThisHole){
      scrOpp++;
      scrCountedThisHole=true;
      console.log('Green miss - counted scrambling opp. scrOpp='+scrOpp);
    }
    shots++;
    currentHoleShots.push({shotNum:shots,lie:null,distanceBefore:15,distanceAfter:null,isPutt:false,fwCounted:false,bunkerCounted:false});
    distanceTitle.innerText=`${ordinal(shots)} Shot Distance`;
    shotDistance.value=15;
    lieTitle.innerText=`Where did your ${ordinal(shots)} shot end?`;
    show('distancePage');
    return;
  }
  if(lie==='GS BUNKER'){
    lastShot.lie=lie;
    // Count bunker opportunity if not already counted
    if(!lastShot.bunkerCounted){
      console.log('Counting GS bunker opp! bunOpp before: '+bunOpp);
      bunOpp++;
      lastShot.bunkerCounted=true;
      console.log('bunOpp after: '+bunOpp);
    }
    // GS bunker always counts as scrambling opportunity (missed green)
    if(!girThisHole && !scrCountedThisHole){
      scrOpp++;
      scrCountedThisHole=true;
      console.log('GS Bunker - counted scrambling opp. scrOpp='+scrOpp);
    }
    shots++;
    currentHoleShots.push({shotNum:shots,lie:null,distanceBefore:30,distanceAfter:null,isPutt:false,fwCounted:false,bunkerCounted:false});
    distanceTitle.innerText=`${ordinal(shots)} Shot Distance`;
    shotDistance.value=30;
    lieTitle.innerText=`Where did your ${ordinal(shots)} shot end?`;
    show('distancePage');
    return;
  }
  shots++;
  let defaultDist=100;
  if(shots===2&&par===5){
    defaultDist=250;
  }
  currentHoleShots.push({shotNum:shots,lie:null,distanceBefore:defaultDist,distanceAfter:null,isPutt:false,fwCounted:false,bunkerCounted:false});
  distanceTitle.innerText=`${ordinal(shots)} Shot Distance`;
  shotDistance.value=defaultDist;
  lieTitle.innerText=`Where did your ${ordinal(shots)} shot end?`;
  show('distancePage');
}

function confirmDistance(){
  const lastShot=currentHoleShots[currentHoleShots.length-1];
  const distance = parseInt(shotDistance.value||0);
  lastShot.distanceBefore = distance;
  
  // Set the previous shot's distanceAfter to this shot's distanceBefore
  if(currentHoleShots.length >= 2){
    const prevShot = currentHoleShots[currentHoleShots.length-2];
    if(prevShot && prevShot.distanceAfter === null){
      prevShot.distanceAfter = distance;
      console.log('Set previous shot distanceAfter to:', distance);
    }
  }
  
  // Don't count stats here - they're counted in selectLie when choosing the lie
  
  show('liePage');
}

function handlePenalty(choice){
  const lastShot=currentHoleShots[currentHoleShots.length-1];
  const lastDistance=lastShot.distanceBefore||100;
  lastShot.distanceAfter=lastDistance;
  currentHoleShots.push({shotNum:shots+1,lie:'PENALTY',distanceBefore:lastDistance,distanceAfter:lastDistance,isPutt:false,fwCounted:false,bunkerCounted:false});
  shots += 2;
  currentHoleShots.push({shotNum:shots,lie:null,distanceBefore:lastDistance,distanceAfter:null,isPutt:false,fwCounted:false,bunkerCounted:false});
  distanceTitle.innerText=`${ordinal(shots)} Shot Distance`;
  shotDistance.value=lastDistance;
  lieTitle.innerText=`Where did your ${ordinal(shots)} shot end?`;
  show('distancePage');
}

function handleRecovery(direction){
  const lastShot=currentHoleShots[currentHoleShots.length-1];
  lastShot.lie='RECOVERY';
  
  // Count as missed fairway left or right on tee shots
  if(shots===1&&(par===4||par===5)&&!fwCountedThisHole){
    fwOpp++;
    if(direction==='LEFT') fwLeft++;
    if(direction==='RIGHT') fwRight++;
    fwCountedThisHole=true;
    lastShot.fwCounted=true;
  }
  
  // Move to next shot
  shots++;
  currentHoleShots.push({shotNum:shots,lie:null,distanceBefore:150,distanceAfter:null,isPutt:false,fwCounted:false,bunkerCounted:false});
  distanceTitle.innerText=`${ordinal(shots)} Shot Distance`;
  shotDistance.value=150;
  lieTitle.innerText=`Where did your ${ordinal(shots)} shot end?`;
  show('distancePage');
}

function handleMissedGreen(direction){
  const lastShot=currentHoleShots[currentHoleShots.length-1];
  lastShot.lie='MISS '+direction;
  
  // Count green miss direction
  girOpp++;
  if(direction==='LEFT') missLeft++;
  if(direction==='RIGHT') missRight++;
  if(direction==='SHORT') missShort++;
  if(direction==='LONG') missLong++;
  
  // Count scrambling opportunity
  if(!girThisHole && !scrCountedThisHole){
    scrOpp++;
    scrCountedThisHole=true;
    console.log('Green miss - counted scrambling opp. scrOpp='+scrOpp);
  }
  
  // Move to next shot with default 15 yards
  shots++;
  currentHoleShots.push({shotNum:shots,lie:null,distanceBefore:15,distanceAfter:null,isPutt:false,fwCounted:false,bunkerCounted:false});
  distanceTitle.innerText=`${ordinal(shots)} Shot Distance`;
  shotDistance.value=15;
  lieTitle.innerText=`Where did your ${ordinal(shots)} shot end?`;
  show('distancePage');
}

function nextPutt(){
  totalPutts++;
  const distInput = document.getElementById('puttDistance');
  // The input value is the distance of THIS putt that was just taken
  const thisPuttDist = parseInt(distInput.value) || 0;
  console.log('nextPutt - this putt was from:', thisPuttDist, 'ft');
  
  const lastShot = currentHoleShots[currentHoleShots.length-1];
  
  // Update the lastShot's distanceBefore to match what user entered (in case they changed it)
  lastShot.distanceBefore = thisPuttDist;
  
  if(putts===0 && girThisHole) firstPuttThisHole = thisPuttDist;
  
  // Set the PREVIOUS putt's distanceAfter to this putt's distanceBefore
  // (The previous putt ended where this putt started)
  if(currentHoleShots.length >= 2){
    const prevShot = currentHoleShots[currentHoleShots.length - 2];
    if(prevShot.isPutt && prevShot.distanceAfter === null){
      prevShot.distanceAfter = thisPuttDist;
      console.log('Set previous putt distanceAfter to:', thisPuttDist);
    }
  }
  
  putts++;
  puttTitle.innerText = `Putt ${putts+1}`;
  puttShotNum.innerText = `Shot ${shots+putts+1}`;
  
  // Clear input and wait for user to enter next putt distance
  // Default to 3 as a reasonable short putt
  distInput.value = 3;
  distInput.setAttribute('value', 3);
  
  // Create placeholder for next putt
  const newShot = {shotNum:shots+putts+1, lie:'PUTT', distanceBefore:3, distanceAfter:null, isPutt:true, fwCounted:false, bunkerCounted:false};
  currentHoleShots.push(newShot);
  
  console.log('Ready for putt', putts+1);
}

function holeOut(){
  totalPutts++;
  const distInput = document.getElementById('puttDistance');
  const thisPuttDist = parseInt(distInput.value) || 0;
  console.log('holeOut - this putt was from:', thisPuttDist, 'ft');
  
  const lastShot = currentHoleShots[currentHoleShots.length-1];
  
  // Update the lastShot's distanceBefore to match what user entered
  lastShot.distanceBefore = thisPuttDist;
  
  if(putts===0){
    onePuttMade++;
    if(girThisHole) firstPuttThisHole = thisPuttDist;
  }
  
  // Ball went in the hole
  lastShot.distanceAfter = 0;
  lastShot.lie = 'HOLED';
  
  // Now we need to set the distanceAfter for the PREVIOUS putt (if there was one)
  // The previous putt's distanceAfter = this putt's distanceBefore
  if(currentHoleShots.length >= 2){
    const prevShot = currentHoleShots[currentHoleShots.length - 2];
    if(prevShot.isPutt && prevShot.distanceAfter === null){
      prevShot.distanceAfter = thisPuttDist;
      console.log('Set previous putt distanceAfter to:', thisPuttDist);
    }
  }
  
  putts++;
  if(putts >= 3) threePlusPutts++;
  if(girThisHole) girPutts += putts;
  if(firstPuttThisHole !== null){
    console.log('Adding to girFirstPuttDist:', firstPuttThisHole, ', was:', girFirstPuttDist);
    girFirstPuttDist += firstPuttThisHole;
    console.log('girFirstPuttDist is now:', girFirstPuttDist);
    firstPuttThisHole = null;
  }
  
  // Check if we got up and down from bunker (1 putt after bunker shot)
  let hitFromBunker = false;
  currentHoleShots.forEach(s => {
    if(s.lie && s.lie.includes('BUNKER')) hitFromBunker = true;
  });
  
  // Count scramble success
  if(putts === 1 && scrCountedThisHole){
    scr++;
    console.log('Scramble success! scr=' + scr);
  }
  
  // Count bunker save
  if(hitFromBunker && putts === 1) bun++;
  
  finishHole();
}

function finishHole(){
  const holeStrokes=shots+putts;
  currentHoleData.score=holeStrokes;
  currentHoleData.putts=putts;
  currentHoleData.shots=currentHoleShots;
  
  // Calculate Strokes Gained for each shot
  let holeSgOTT = 0, holeSgAPP = 0, holeSgARG = 0, holeSgPutt = 0;
  
  currentHoleShots.forEach((s, idx) => {
    s.sg = 0; // Initialize SG for this shot
    if(!s.lie || s.lie === 'PENALTY') return;
    
    const nextShot = currentHoleShots[idx + 1];
    const distBefore = s.distanceBefore || 0;
    const distAfter = s.distanceAfter || 0;
    
    // Determine what kind of shot this was
    const shotNum = s.shotNum;
    const isTeeShotPar45 = shotNum === 1 && (par === 4 || par === 5);
    const isTeeShotPar3 = shotNum === 1 && par === 3;
    const isPutt = s.isPutt;
    const isShortGame = !isPutt && distBefore <= 50 && !isTeeShotPar45;
    const isApproach = !isPutt && !isTeeShotPar45 && !isShortGame;
    
    if(isPutt){
      // Putting SG calculated separately below
    } else if(s.lie === 'HOLED'){
      // Holed from off green - huge gain
      let expectedBefore = 0;
      let sg = 0;
      if(isTeeShotPar45){
        expectedBefore = getExpectedStrokes(currentHoleData.yards, 'TEE');
        sg = expectedBefore - 1;
        holeSgOTT += sg;
      } else if(isTeeShotPar3){
        expectedBefore = getExpectedStrokes(currentHoleData.yards, 'TEE');
        sg = expectedBefore - 1;
        holeSgAPP += sg;
      } else if(isShortGame){
        const prevShot = currentHoleShots[idx - 1];
        const prevLie = prevShot ? prevShot.lie : 'FAIRWAY';
        expectedBefore = getExpectedStrokes(distBefore, prevLie);
        sg = expectedBefore - 1;
        holeSgARG += sg;
      } else {
        const prevShot = currentHoleShots[idx - 1];
        const prevLie = prevShot ? prevShot.lie : 'FAIRWAY';
        expectedBefore = getExpectedStrokes(distBefore, prevLie);
        sg = expectedBefore - 1;
        holeSgAPP += sg;
      }
      s.sg = sg;
    } else if(isTeeShotPar45){
      // Off the tee on par 4/5
      const expectedBefore = getExpectedStrokes(currentHoleData.yards, 'TEE');
      let expectedAfter;
      if(s.lie === 'GREEN'){
        // distAfter is already in feet for green
        expectedAfter = getExpectedPutts(distAfter);
      } else {
        expectedAfter = distAfter > 0 ? getExpectedStrokes(distAfter, s.lie) : 2.5;
      }
      const sg = expectedBefore - expectedAfter - 1;
      s.sg = sg;
      holeSgOTT += sg;
      console.log(`OTT: ${currentHoleData.yards}yds TEE -> ${s.lie === 'GREEN' ? distAfter + 'ft' : distAfter + 'yds'} ${s.lie}, expected ${expectedBefore.toFixed(2)} -> ${expectedAfter.toFixed(2)}, SG: ${sg.toFixed(2)}`);
    } else if(isTeeShotPar3){
      // Par 3 tee shot counts as approach
      const expectedBefore = getExpectedStrokes(currentHoleData.yards, 'TEE');
      let expectedAfter;
      if(s.lie === 'GREEN'){
        // distAfter is already in feet for green
        expectedAfter = getExpectedPutts(distAfter);
      } else {
        expectedAfter = distAfter > 0 ? getExpectedStrokes(distAfter, s.lie) : 2.5;
      }
      const sg = expectedBefore - expectedAfter - 1;
      s.sg = sg;
      holeSgAPP += sg;
      console.log(`APP (Par 3): ${currentHoleData.yards}yds TEE -> ${s.lie === 'GREEN' ? distAfter + 'ft' : distAfter + 'yds'} ${s.lie}, expected ${expectedBefore.toFixed(2)} -> ${expectedAfter.toFixed(2)}, SG: ${sg.toFixed(2)}`);
    } else if(isShortGame){
      // Around the green (50 yards and in, not putting)
      const prevShot = currentHoleShots[idx - 1];
      const prevLie = prevShot ? prevShot.lie : 'FAIRWAY';
      const expectedBefore = getExpectedStrokes(distBefore, prevLie);
      let expectedAfter;
      if(s.lie === 'GREEN'){
        // distAfter is already in feet for green
        expectedAfter = getExpectedPutts(distAfter);
      } else {
        expectedAfter = distAfter > 0 ? getExpectedStrokes(distAfter, s.lie) : 2.5;
      }
      const sg = expectedBefore - expectedAfter - 1;
      s.sg = sg;
      holeSgARG += sg;
      console.log(`ARG: ${distBefore}yds ${prevLie} -> ${s.lie === 'GREEN' ? distAfter + 'ft' : distAfter + 'yds'} ${s.lie}, expected ${expectedBefore.toFixed(2)} -> ${expectedAfter.toFixed(2)}, SG: ${sg.toFixed(2)}`);
    } else if(isApproach){
      // Approach shot (>50 yards, not tee shot on par 4/5)
      const prevShot = currentHoleShots[idx - 1];
      const prevLie = prevShot ? prevShot.lie : 'FAIRWAY';
      const expectedBefore = getExpectedStrokes(distBefore, prevLie);
      let expectedAfter;
      if(s.lie === 'GREEN'){
        // distAfter is already in feet for green
        expectedAfter = getExpectedPutts(distAfter);
      } else {
        expectedAfter = distAfter > 0 ? getExpectedStrokes(distAfter, s.lie) : 2.5;
      }
      const sg = expectedBefore - expectedAfter - 1;
      s.sg = sg;
      holeSgAPP += sg;
      console.log(`APP: ${distBefore}yds ${prevLie} -> ${s.lie === 'GREEN' ? distAfter + 'ft' : distAfter + 'yds'} ${s.lie}, expected ${expectedBefore.toFixed(2)} -> ${expectedAfter.toFixed(2)}, SG: ${sg.toFixed(2)}`);
    }
  });
  
  // Calculate SG Putting for each putt
  let firstPuttDist = 0;
  let numPutts = 0;
  currentHoleShots.forEach((s, idx) => {
    if(s.isPutt){
      const puttDist = s.distanceBefore || 0;
      if(firstPuttDist === 0) firstPuttDist = puttDist;
      const expectedBefore = getExpectedPutts(puttDist);
      let expectedAfter = 0;
      if(s.lie === 'HOLED' || s.distanceAfter === 0){
        expectedAfter = 0; // Holed it
      } else if(s.distanceAfter){
        expectedAfter = getExpectedPutts(s.distanceAfter);
      }
      const sg = expectedBefore - expectedAfter - 1;
      s.sg = sg;
      holeSgPutt += sg;
      numPutts++;
    }
    if(s.lie === 'HOLED' && !s.isPutt){
      // Already counted above for holed shots from off green
    }
  });
  
  currentHoleData.firstPuttDist = firstPuttDist;
  currentHoleData.expectedPutts = firstPuttDist > 0 ? getExpectedPutts(firstPuttDist) : 0;
  if(numPutts > 0){
    console.log(`Hole ${currentHole}: ${numPutts} putts from ${firstPuttDist}ft, SG Putting: ${holeSgPutt.toFixed(2)}`);
  }
  
  // Store hole SG data
  currentHoleData.sgOTT = holeSgOTT;
  currentHoleData.sgAPP = holeSgAPP;
  currentHoleData.sgARG = holeSgARG;
  currentHoleData.sgPutting = holeSgPutt;
  
  // Add to totals
  sgOTTTotal += holeSgOTT;
  sgAPPTotal += holeSgAPP;
  sgARGTotal += holeSgARG;
  sgPuttingTotal += holeSgPutt;
  
  console.log(`Hole ${currentHole} SG: OTT=${holeSgOTT.toFixed(2)}, APP=${holeSgAPP.toFixed(2)}, ARG=${holeSgARG.toFixed(2)}, Putt=${holeSgPutt.toFixed(2)}`);
  
  allHoles.push(currentHoleData);
  
  if(par===3){c3++;p3+=holeStrokes;}
  if(par===4){c4++;p4+=holeStrokes;}
  if(par===5){c5++;p5+=holeStrokes;}
  totalStrokes+=holeStrokes;
  totalPar+=par;
  const d=totalStrokes-totalPar;
  scoreBar.innerText=d===0?`E through ${currentHole}`:`${d>0?'+':''}${d} through ${currentHole}`;
  if(currentHole<totalHoles){
    currentHole++;
    holeHeader.innerText=`Hole ${currentHole}`;
    show('parPage');
  }else{
    scoreBar.style.display='none';
    renderSummary();
    show('summaryPage');
  }
}

function renderSummary(){
  sumScore.innerText=totalStrokes;
  sumPar.innerText=totalPar;
  const d=totalStrokes-totalPar;
  sumToPar.innerText=d===0?'E':`${d>0?'+':''}${d}`;
  const dt=new Date(roundDate.value);
  roundMeta.innerText=`${playerName.value||'Player'} · ${courseName.value||'Course'} · ${dt.getMonth()+1}/${dt.getDate()}/${dt.getFullYear()}`;

  fwHitS.innerText=fwHit;fwOppS.innerText=fwOpp;fwPctS.innerText=fwOpp?Math.round(fwHit/fwOpp*100):0;
  fwLeftS.innerText=fwLeft;fwRightS.innerText=fwRight;
  fwLeftPctS.innerText=fwOpp?Math.round(fwLeft/fwOpp*100):0;
  fwRightPctS.innerText=fwOpp?Math.round(fwRight/fwOpp*100):0;

  girS.innerText=gir;girTotS.innerText=totalHoles;girPctS.innerText=totalHoles?Math.round(gir/totalHoles*100):0;
  proxGirS.innerText=gir?Math.round(girFirstPuttDist/gir):0;

  scrS.innerText=scr;scrOppS.innerText=scrOpp;scrPctS.innerText=scrOpp?Math.round(scr/scrOpp*100):0;
  bunS.innerText=bun;bunOppS.innerText=bunOpp;bunPctS.innerText=bunOpp?Math.round(bun/bunOpp*100):0;

  avgP3.innerText=c3?(p3/c3).toFixed(1):'–';
  avgP4.innerText=c4?(p4/c4).toFixed(1):'–';
  avgP5.innerText=c5?(p5/c5).toFixed(1):'–';

  pph.innerText=`Putts per Hole- ${(totalPutts/totalHoles).toFixed(1)}`;
  ppg.innerText=`Putts per GIR- ${gir?(girPutts/gir).toFixed(1):'–'}`;

  threePutts.innerText=`Three or more putts- ${threePlusPutts}`;
  onePuttPct.innerText=`One-Putt %- ${onePuttOpp?Math.round(onePuttMade/onePuttOpp*100):0}%`;
  
  // Color coding helper functions
  // green = good, white = average, red = below average
  function colorStat(el, val, goodThreshold, avgThreshold, higherIsBetter=true){
    if(val === '–' || val === 'N/A') return;
    const numVal = parseFloat(val);
    if(isNaN(numVal)) return;
    if(higherIsBetter){
      if(numVal >= goodThreshold) el.style.color = '#4caf50'; // green
      else if(numVal >= avgThreshold) el.style.color = '#ffffff'; // white
      else el.style.color = '#f44336'; // red
    } else {
      if(numVal <= goodThreshold) el.style.color = '#4caf50'; // green
      else if(numVal <= avgThreshold) el.style.color = '#ffffff'; // white
      else el.style.color = '#f44336'; // red
    }
  }
  
  // Avg Par scores - lower is better. Par is avg, -0.2 is good
  if(c3) colorStat(avgP3, avgP3.innerText, 2.9, 3.1, false);
  if(c4) colorStat(avgP4, avgP4.innerText, 3.9, 4.1, false);
  if(c5) colorStat(avgP5, avgP5.innerText, 4.9, 5.1, false);
  
  // Fairway % - higher is better. 60% good, 50% avg
  const fwPct = fwOpp ? Math.round(fwHit/fwOpp*100) : 0;
  colorStat(fwPctS, fwPct, 60, 50, true);
  
  // GIR % - higher is better. 50% good, 33% avg
  const girPct = totalHoles ? Math.round(gir/totalHoles*100) : 0;
  colorStat(girPctS, girPct, 50, 33, true);
  
  // Proximity when GIR - lower is better. 25ft good, 35ft avg
  const proxGir = gir ? Math.round(girFirstPuttDist/gir) : 0;
  colorStat(proxGirS, proxGir, 25, 35, false);
  
  // Scrambling % - higher is better. 50% good, 33% avg. White if 0 opportunities
  const scrPct = scrOpp ? Math.round(scr/scrOpp*100) : 0;
  if(scrOpp > 0) colorStat(scrPctS, scrPct, 50, 33, true);
  else scrPctS.style.color = '#ffffff';
  
  // Bunker save % - higher is better. 40% good, 25% avg. White if 0 opportunities
  const bunPct = bunOpp ? Math.round(bun/bunOpp*100) : 0;
  if(bunOpp > 0) colorStat(bunPctS, bunPct, 40, 25, true);
  else bunPctS.style.color = '#ffffff';
  
  // Putts per hole - lower is better. 1.8 good, 2.0 avg
  const pphVal = (totalPutts/totalHoles).toFixed(1);
  const pphSpan = document.createElement('span');
  pph.innerHTML = `Putts per Hole- <span class="num" id="pphVal">${pphVal}</span>`;
  colorStat(document.getElementById('pphVal'), pphVal, 1.8, 2.0, false);
  
  // Putts per GIR - lower is better. 1.8 good, 2.0 avg
  const ppgVal = gir ? (girPutts/gir).toFixed(1) : '–';
  ppg.innerHTML = `Putts per GIR- <span class="num" id="ppgVal">${ppgVal}</span>`;
  if(ppgVal !== '–') colorStat(document.getElementById('ppgVal'), ppgVal, 1.8, 2.0, false);
  
  // Three putts - lower is better. 0 good, 2 avg
  threePutts.innerHTML = `Three or more putts- <span class="num" id="threePuttsVal">${threePlusPutts}</span>`;
  colorStat(document.getElementById('threePuttsVal'), threePlusPutts, 0, 2, false);
  
  // One putt % - higher is better. 40% good, 30% avg
  const onePuttPctVal = onePuttOpp ? Math.round(onePuttMade/onePuttOpp*100) : 0;
  onePuttPct.innerHTML = `One-Putt %- <span class="num" id="onePuttPctVal">${onePuttPctVal}%</span>`;
  colorStat(document.getElementById('onePuttPctVal'), onePuttPctVal, 40, 30, true);
  
  // Display Strokes Gained stats - use actual calculated values
  const sgTotal = sgOTTTotal + sgAPPTotal + sgARGTotal + sgPuttingTotal;
  
  // Get handicap selection for display
  const handicapSelect = document.getElementById('playerHandicap');
  const handicapVal = handicapSelect.value;
  const handicapLabels = {
    'pro': 'Tour Pro',
    '0': 'Scratch',
    '5': '5 HCP',
    '10': '10 HCP',
    '15': '15 HCP',
    '20': '20 HCP',
    '25': '25 HCP'
  };
  const handicapLabel = handicapLabels[handicapVal] || 'Tour Pro';
  
  // Update the SG Total label with handicap comparison
  document.querySelector('#summaryPage .stat.center span[style*="font-weight:600"]').nextElementSibling.nextElementSibling.innerText = `(vs ${handicapLabel})`;
  
  function formatSG(val){
    return val >= 0 ? `+${val.toFixed(2)}` : val.toFixed(2);
  }
  function colorSG(el, val){
    el.style.color = val >= 0 ? '#4caf50' : '#f44336';
  }
  
  const sgOTTEl = document.getElementById('sgOTT');
  sgOTTEl.innerText = formatSG(sgOTTTotal);
  colorSG(sgOTTEl, sgOTTTotal);
  
  const sgAPPEl = document.getElementById('sgAPP');
  sgAPPEl.innerText = formatSG(sgAPPTotal);
  colorSG(sgAPPEl, sgAPPTotal);
  
  const sgARGEl = document.getElementById('sgARG');
  sgARGEl.innerText = formatSG(sgARGTotal);
  colorSG(sgARGEl, sgARGTotal);
  
  const sgPuttingEl = document.getElementById('sgPuttingDisplay');
  sgPuttingEl.innerText = formatSG(sgPuttingTotal);
  colorSG(sgPuttingEl, sgPuttingTotal);
  
  const sgTotalEl = document.getElementById('sgTotal');
  sgTotalEl.innerText = formatSG(sgTotal);
  colorSG(sgTotalEl, sgTotal);
}

function formatDateForDisplay(dateStr){
  if(!dateStr) return '';
  const d = new Date(dateStr);
  return `${d.getMonth()+1}/${d.getDate()}/${d.getFullYear()}`;
}

function formatDateForFilename(dateStr){
  if(!dateStr) return 'round';
  const d = new Date(dateStr);
  return `${d.getMonth()+1}-${d.getDate()}-${d.getFullYear()}`;
}

function exportToCSV(){
  if(!allHoles || allHoles.length===0){
    alert('No round data to export. Please complete at least one hole.');
    return;
  }
  
  const csv = generateCSV();
  
  // Create filename from player name, date, course name
  const pName = (playerName.value||'Player').replace(/[^a-zA-Z0-9]/g, '');
  const cName = (courseName.value||'Course').replace(/[^a-zA-Z0-9]/g, '');
  const rDate = formatDateForFilename(roundDate.value);
  const filename = `${pName}_${rDate}_${cName}.csv`;
  
  const blob=new Blob([csv],{type:'text/csv'});
  const url=window.URL.createObjectURL(blob);
  const a=document.createElement('a');
  a.href=url;
  a.download=filename;
  a.click();
  window.URL.revokeObjectURL(url);
}

function exportToExcel(){
  if(!allHoles || allHoles.length===0){
    alert('No round data to export. Please complete at least one hole.');
    return;
  }
  
  const wb = XLSX.utils.book_new();
  
  // Calculate common stats
  let eagles=0,birdies=0,pars=0,bogeys=0,doubleOrWorse=0;
  allHoles.forEach(h=>{
    const diff=h.score-h.par;
    if(diff<=-2) eagles++;
    else if(diff===-1) birdies++;
    else if(diff===0) pars++;
    else if(diff===1) bogeys++;
    else doubleOrWorse++;
  });
  
  let totalYards=0;
  allHoles.forEach(h=>totalYards+=h.yards);
  
  // Calculate penalties
  let par3TeePenalties=0, par45TeePenalties=0, approachPenalties=0, shortGamePenalties=0;
  allHoles.forEach(h=>{
    h.shots.forEach((s,idx)=>{
      if(s.lie==='PENALTY'){
        const prevShot=h.shots[idx-1];
        if(prevShot){
          // Tee shot penalty (shot 1)
          if(prevShot.shotNum===1){
            if(h.par===3) par3TeePenalties++;
            else par45TeePenalties++;
          }
          // Approach penalty (over 100 yards)
          else if(prevShot.distanceBefore>100){
            approachPenalties++;
          }
          // Short game penalty (100 yards or less)
          else{
            shortGamePenalties++;
          }
        }
      }
    });
  });
  
  // ============ SHEET 1: SCORING ============
  // Split holes into front 9 and back 9
  const front9 = allHoles.slice(0, Math.min(9, allHoles.length));
  const back9 = allHoles.slice(9);
  
  let front9Yards=0, front9Par=0, front9Score=0, front9Putts=0;
  front9.forEach(h=>{front9Yards+=h.yards;front9Par+=h.par;front9Score+=h.score;front9Putts+=h.putts;});
  
  let back9Yards=0, back9Par=0, back9Score=0, back9Putts=0;
  back9.forEach(h=>{back9Yards+=h.yards;back9Par+=h.par;back9Score+=h.score;back9Putts+=h.putts;});
  
  let scoringData = [
    ['SCORING', '', '', '', '', 'AVERAGES', '', '', 'SCORE DISTRIBUTION'],
    [],
    ['Player:', playerName.value||'Player', '', '', '', 'Avg Par 3', c3?(p3/c3).toFixed(2):'N/A', '', 'Eagles', eagles],
    ['Handicap:', document.getElementById('playerHandicap').value||'N/A', '', '', '', 'Avg Par 4', c4?(p4/c4).toFixed(2):'N/A', '', 'Birdies', birdies],
    ['Course:', courseName.value||'Course', '', '', '', 'Avg Par 5', c5?(p5/c5).toFixed(2):'N/A', '', 'Pars', pars],
    ['Date:', formatDateForDisplay(roundDate.value), '', '', '', '', '', '', 'Bogeys', bogeys],
    ['', '', '', '', '', '', '', '', 'Double+', doubleOrWorse],
    [],
    // Front 9
    ['Hole', ...front9.map(h=>h.hole), 'OUT'],
    ['Yards', ...front9.map(h=>h.yards), front9Yards],
    ['Par', ...front9.map(h=>h.par), front9Par],
    ['Score', ...front9.map(h=>h.score), front9Score],
    ['Putts', ...front9.map(h=>h.putts), front9Putts]
  ];
  
  // Add back 9 if exists
  if(back9.length>0){
    scoringData.push([]);
    scoringData.push(['Hole', ...back9.map(h=>h.hole), 'IN', 'TOTAL']);
    scoringData.push(['Yards', ...back9.map(h=>h.yards), back9Yards, totalYards]);
    scoringData.push(['Par', ...back9.map(h=>h.par), back9Par, totalPar]);
    scoringData.push(['Score', ...back9.map(h=>h.score), back9Score, totalStrokes]);
    scoringData.push(['Putts', ...back9.map(h=>h.putts), back9Putts, totalPutts]);
  }
  
  
  const ws1 = XLSX.utils.aoa_to_sheet(scoringData);
  XLSX.utils.book_append_sheet(wb, ws1, 'Scoring');
  
  // ============ SHEET 2: STROKES GAINED ============
  const sgTotal = sgOTTTotal + sgAPPTotal + sgARGTotal + sgPuttingTotal;
  
  // Helper function to categorize lies for strokes gained
  function categorizeLie(lie, isPutt, isFromTee){
    if(isFromTee) return 'Tee';
    if(isPutt || lie === 'GREEN' || lie === 'PUTT') return 'Green';
    if(lie === 'FAIRWAY') return 'Fairway';
    if(lie === 'LEFT ROUGH' || lie === 'RIGHT ROUGH') return 'Rough';
    if(lie === 'MISS LEFT' || lie === 'MISS RIGHT' || lie === 'MISS SHORT' || lie === 'MISS LONG') return 'Rough';
    if(lie === 'GS BUNKER' || lie === 'FW BUNKER') return 'Sand';
    if(lie === 'RECOVERY' || lie === 'PENALTY' || lie === 'OB' || lie === 'WATER') return 'Recovery';
    return 'Rough';
  }
  
  let sgSummaryData = [
    ['STROKES GAINED'],
    [],
    ['SG: Total', sgTotal.toFixed(2)],
    ['SG: Off The Tee', sgOTTTotal.toFixed(2)],
    ['SG: Approach', sgAPPTotal.toFixed(2)],
    ['SG: Around the Green', sgARGTotal.toFixed(2)],
    ['SG: Putting', sgPuttingTotal.toFixed(2)],
    [],
    ['SHOT BY SHOT BREAKDOWN'],
    ['Hole', 'Par', 'Shot #', 'Start Distance', 'Start Lie', 'End Lie', 'End Distance', 'Strokes Gained']
  ];
  
  // Add shot-by-shot data
  allHoles.forEach(h=>{
    h.shots.forEach((s, idx)=>{
      const nextShot = h.shots[idx+1];
      const prevShot = idx > 0 ? h.shots[idx-1] : null;
      
      // Start lie category
      let startLieCat = '';
      if(s.shotNum === 1){
        startLieCat = 'Tee';
      } else if(s.isPutt){
        startLieCat = 'Green';
      } else if(prevShot && prevShot.lie){
        startLieCat = categorizeLie(prevShot.lie, false, false);
      } else {
        startLieCat = 'Unknown';
      }
      
      // Start distance
      let startDist = s.distanceBefore || 0;
      let startDistDisplay = '';
      if(s.isPutt){
        startDistDisplay = startDist + ' ft';
      } else {
        startDistDisplay = startDist + ' yds';
      }
      
      // End lie category
      let endLieCat = '';
      if(s.lie === 'HOLED'){
        endLieCat = 'Holed';
      } else {
        endLieCat = categorizeLie(s.lie, s.isPutt, false);
      }
      
      // End distance
      let endDistDisplay = '0';
      if(s.lie === 'HOLED'){
        endDistDisplay = '0';
      } else if(s.distanceAfter != null){
        if(nextShot && nextShot.isPutt){
          endDistDisplay = s.distanceAfter + ' ft';
        } else if(s.isPutt){
          endDistDisplay = s.distanceAfter + ' ft';
        } else {
          endDistDisplay = s.distanceAfter + ' yds';
        }
      } else if(nextShot){
        if(nextShot.isPutt){
          endDistDisplay = nextShot.distanceBefore != null ? nextShot.distanceBefore + ' ft' : '';
        } else {
          endDistDisplay = nextShot.distanceBefore != null ? nextShot.distanceBefore + ' yds' : '';
        }
      }
      
      // Format SG for display
      let sgDisplay = '';
      if(s.sg != null){
        if(s.sg >= 0){
          sgDisplay = '+' + s.sg.toFixed(2);
        } else {
          sgDisplay = s.sg.toFixed(2);
        }
      }
      
      sgSummaryData.push([
        h.hole,
        h.par,
        s.shotNum,
        startDistDisplay,
        startLieCat,
        endLieCat,
        endDistDisplay,
        sgDisplay
      ]);
    });
  });
  
  const wsSG = XLSX.utils.aoa_to_sheet(sgSummaryData);
  XLSX.utils.book_append_sheet(wb, wsSG, 'Strokes Gained');
  
  // ============ SHEET 3: OFF THE TEE ============
  let drivingDistances=[];
  let driveDetails=[];
  let longestDrive = 0;
  let shortestDrive = 999;
  allHoles.forEach(h=>{
    if((h.par===4||h.par===5)&&h.shots.length>0&&h.shots[0].distanceAfter!=null){
      const driveDistance = h.yards - h.shots[0].distanceAfter;
      drivingDistances.push(driveDistance);
      driveDetails.push({hole: h.hole, distance: driveDistance, par: h.par, yards: h.yards});
      if(driveDistance > longestDrive) longestDrive = driveDistance;
      if(driveDistance < shortestDrive) shortestDrive = driveDistance;
    }
  });
  const avgDrive=drivingDistances.length?Math.round(drivingDistances.reduce((a,b)=>a+b,0)/drivingDistances.length):0;
  if(drivingDistances.length === 0) shortestDrive = 0;
  
  let teeData = [
    ['OFF THE TEE'],
    [],
    ['SG: Off The Tee', sgOTTTotal.toFixed(2)],
    [],
    ['FAIRWAY ACCURACY'],
    ['Fairways Hit', `${fwHit}/${fwOpp}`, fwOpp?Math.round(fwHit/fwOpp*100)+'%':'0%'],
    ['Missed Left', fwLeft, fwOpp?Math.round(fwLeft/fwOpp*100)+'%':'0%'],
    ['Missed Right', fwRight, fwOpp?Math.round(fwRight/fwOpp*100)+'%':'0%'],
    [],
    ['DRIVING DISTANCE'],
    ['Average', avgDrive+' yards'],
    ['Longest', longestDrive+' yards'],
    ['Shortest', shortestDrive+' yards'],
    [],
    ['DRIVE BY HOLE'],
    ['Hole', 'Par', 'Drive Distance']
  ];
  
  driveDetails.forEach(d=>{
    teeData.push([d.hole, d.par, d.distance+' yds']);
  });
  
  teeData.push([]);
  teeData.push(['PENALTIES OFF THE TEE']);
  teeData.push(['Par 3 Tee Penalties', par3TeePenalties]);
  teeData.push(['Par 4/5 Tee Penalties', par45TeePenalties]);
  
  const ws2 = XLSX.utils.aoa_to_sheet(teeData);
  XLSX.utils.book_append_sheet(wb, ws2, 'Off The Tee');
  
  // ============ SHEET 3: APPROACH ============
  let par3ApproachDist=[],par4ApproachDist=[],par5ApproachDist=[];
  let par3Approaches=[],par4Approaches=[],par5Approaches=[];
  
  allHoles.forEach(h=>{
    h.shots.forEach((s,idx)=>{
      if(!s.isPutt&&s.distanceBefore&&s.lie==='GREEN'){
        if(h.par===3){
          par3ApproachDist.push(s.distanceBefore);
          par3Approaches.push(s.distanceAfter||0);
        }else if(h.par===4){
          par4ApproachDist.push(s.distanceBefore);
          par4Approaches.push(s.distanceAfter||0);
        }else if(h.par===5){
          par5ApproachDist.push(s.distanceBefore);
          par5Approaches.push(s.distanceAfter||0);
        }
      }
    });
  });
  
  const avgPar3Dist=par3ApproachDist.length?Math.round(par3ApproachDist.reduce((a,b)=>a+b,0)/par3ApproachDist.length):0;
  const avgPar3=par3Approaches.length?Math.round(par3Approaches.reduce((a,b)=>a+b,0)/par3Approaches.length):0;
  const avgPar4Dist=par4ApproachDist.length?Math.round(par4ApproachDist.reduce((a,b)=>a+b,0)/par4ApproachDist.length):0;
  const avgPar4=par4Approaches.length?Math.round(par4Approaches.reduce((a,b)=>a+b,0)/par4Approaches.length):0;
  const avgPar5Dist=par5ApproachDist.length?Math.round(par5ApproachDist.reduce((a,b)=>a+b,0)/par5ApproachDist.length):0;
  const avgPar5=par5Approaches.length?Math.round(par5Approaches.reduce((a,b)=>a+b,0)/par5Approaches.length):0;
  
  const approachRanges=[
    {min:101,max:125,shots:[],label:'101-125 yards'},
    {min:126,max:150,shots:[],label:'126-150 yards'},
    {min:151,max:175,shots:[],label:'151-175 yards'},
    {min:176,max:200,shots:[],label:'176-200 yards'},
    {min:201,max:225,shots:[],label:'201-225 yards'},
    {min:226,max:250,shots:[],label:'226-250 yards'},
    {min:251,max:275,shots:[],label:'251-275 yards'},
    {min:276,max:999,shots:[],label:'276+ yards'}
  ];
  
  allHoles.forEach(h=>{
    h.shots.forEach((s,idx)=>{
      const distBefore=s.distanceBefore||0;
      if(!s.isPutt&&distBefore>100&&s.lie==='GREEN'){
        approachRanges.forEach(r=>{
          if(distBefore>=r.min&&distBefore<=r.max){
            r.shots.push(s.distanceAfter||0);
          }
        });
      }
    });
  });
  
  let approachData = [
    ['APPROACH'],
    [],
    ['SG: Approach', sgAPPTotal.toFixed(2)],
    [],
    ['GIR', `${gir}/${totalHoles}`, totalHoles?Math.round(gir/totalHoles*100)+'%':'0%'],
    ['Proximity when GIR', (gir?Math.round(girFirstPuttDist/gir):0)+' ft'],
    [],
    ['MISSED GREENS'],
    ['Short', missShort, girOpp?Math.round(missShort/girOpp*100)+'%':'0%'],
    ['Long', missLong, girOpp?Math.round(missLong/girOpp*100)+'%':'0%'],
    ['Left', missLeft, girOpp?Math.round(missLeft/girOpp*100)+'%':'0%'],
    ['Right', missRight, girOpp?Math.round(missRight/girOpp*100)+'%':'0%'],
    [],
    ['Approach by Distance', '# of Shots', 'Avg Proximity']
  ];
  
  approachRanges.forEach(r=>{
    const avg=r.shots.length?Math.round(r.shots.reduce((a,b)=>a+b,0)/r.shots.length):0;
    approachData.push([r.label, r.shots.length, avg+' ft']);
  });
  
  approachData.push([]);
  approachData.push(['Avg Par 3 Tee Shot Distance', avgPar3Dist+' yds', par3ApproachDist.length+' shots']);
  approachData.push(['Avg Par 3 Tee Shot Proximity', avgPar3+' ft']);
  approachData.push([]);
  approachData.push(['Avg Par 4 Approach Distance', avgPar4Dist+' yds', par4ApproachDist.length+' shots']);
  approachData.push(['Avg Par 4 Approach Proximity', avgPar4+' ft']);
  approachData.push([]);
  approachData.push(['Avg Par 5 Approach Distance', avgPar5Dist+' yds', par5ApproachDist.length+' shots']);
  approachData.push(['Avg Par 5 Approach Proximity', avgPar5+' ft']);
  approachData.push([]);
  approachData.push(['PENALTIES ON APPROACH']);
  approachData.push(['Approach Shot Penalties', approachPenalties]);
  
  const ws3 = XLSX.utils.aoa_to_sheet(approachData);
  XLSX.utils.book_append_sheet(wb, ws3, 'Approach');
  
  // ============ SHEET 4: AROUND THE GREEN ============
  let bunkerShots=[];
  allHoles.forEach(h=>{
    h.shots.forEach((s,idx)=>{
      if(s.lie&&s.lie.includes('BUNKER')&&h.shots[idx+1]){
        const nextShot=h.shots[idx+1];
        if(nextShot.lie==='GREEN'){
          bunkerShots.push(nextShot.distanceAfter||0);
        }
      }
    });
  });
  const avgBunkerProx=bunkerShots.length?Math.round(bunkerShots.reduce((a,b)=>a+b,0)/bunkerShots.length):0;
  
  const shortRanges=[
    {min:0,max:25,shots:[],label:'0-25 yards'},
    {min:26,max:50,shots:[],label:'26-50 yards'},
    {min:51,max:75,shots:[],label:'51-75 yards'},
    {min:76,max:100,shots:[],label:'76-100 yards'}
  ];
  
  allHoles.forEach(h=>{
    h.shots.forEach((s,idx)=>{
      const distBefore=s.distanceBefore||0;
      if(!s.isPutt&&distBefore>0&&distBefore<=100&&s.lie==='GREEN'){
        shortRanges.forEach(r=>{
          if(distBefore>=r.min&&distBefore<=r.max){
            r.shots.push(s.distanceAfter||0);
          }
        });
      }
    });
  });
  
  let shortGameData = [
    ['AROUND THE GREEN'],
    [],
    ['SG: Around the Green', sgARGTotal.toFixed(2)],
    [],
    ['Scrambling', `${scr}/${scrOpp}`, scrOpp?Math.round(scr/scrOpp*100)+'%':'0%'],
    ['Up & Down from Bunkers', `${bun}/${bunOpp}`, bunOpp?Math.round(bun/bunOpp*100)+'%':'0%'],
    ['Avg Proximity from Bunkers', avgBunkerProx+' ft', bunkerShots.length+' shots'],
    [],
    ['Around the Green by Distance', '# of Shots', 'Avg Proximity']
  ];
  
  shortRanges.forEach(r=>{
    const avg=r.shots.length?Math.round(r.shots.reduce((a,b)=>a+b,0)/r.shots.length):0;
    shortGameData.push([r.label, r.shots.length, avg+' ft']);
  });
  
  shortGameData.push([]);
  shortGameData.push(['PENALTIES AROUND THE GREEN']);
  shortGameData.push(['Around the Green Penalties', shortGamePenalties]);
  
  const ws4 = XLSX.utils.aoa_to_sheet(shortGameData);
  XLSX.utils.book_append_sheet(wb, ws4, 'Around the Green');
  
  // ============ SHEET 5: PUTTING ============
  // Calculate additional putting stats
  let puttDistances = [];
  let madePuttDistances = [];
  let longestMadePutt = 0;
  let avgFirstPuttDist = 0;
  let firstPuttCount = 0;
  
  allHoles.forEach(h=>{
    if(h.firstPuttDist){
      puttDistances.push(h.firstPuttDist);
      avgFirstPuttDist += h.firstPuttDist;
      firstPuttCount++;
    }
    // Check for made putts (one-putts)
    if(h.putts === 1 && h.firstPuttDist){
      madePuttDistances.push(h.firstPuttDist);
      if(h.firstPuttDist > longestMadePutt) longestMadePutt = h.firstPuttDist;
    }
  });
  avgFirstPuttDist = firstPuttCount > 0 ? Math.round(avgFirstPuttDist / firstPuttCount) : 0;
  
  // Putting by distance ranges
  const puttRanges = [
    {min: 0, max: 5, made: 0, total: 0, label: '0-5 ft'},
    {min: 6, max: 10, made: 0, total: 0, label: '6-10 ft'},
    {min: 11, max: 20, made: 0, total: 0, label: '11-20 ft'},
    {min: 21, max: 30, made: 0, total: 0, label: '21-30 ft'},
    {min: 31, max: 999, made: 0, total: 0, label: '30+ ft'}
  ];
  
  allHoles.forEach(h=>{
    if(h.firstPuttDist && h.putts >= 1){
      puttRanges.forEach(r=>{
        if(h.firstPuttDist >= r.min && h.firstPuttDist <= r.max){
          r.total++;
          if(h.putts === 1) r.made++;
        }
      });
    }
  });
  
  let puttingData = [
    ['PUTTING'],
    [],
    ['SG: Putting', sgPuttingTotal.toFixed(2)],
    [],
    ['PUTTING SUMMARY'],
    ['Total Putts', totalPutts],
    ['Putts per Hole', (totalPutts/totalHoles).toFixed(1)],
    ['Putts per GIR', gir?(girPutts/gir).toFixed(1):'N/A'],
    ['Avg First Putt Distance', avgFirstPuttDist + ' ft'],
    [],
    ['PUTTING PERFORMANCE'],
    ['One-Putts', onePuttMade, (onePuttOpp?Math.round(onePuttMade/onePuttOpp*100):0)+'%'],
    ['Two-Putts', totalHoles - onePuttMade - threePlusPutts],
    ['Three-Putts', threePlusPutts],
    ['Longest Made Putt', longestMadePutt + ' ft'],
    [],
    ['MAKE % BY DISTANCE'],
    ['Distance', 'Made/Total', 'Make %']
  ];
  
  puttRanges.forEach(r=>{
    if(r.total > 0){
      puttingData.push([r.label, `${r.made}/${r.total}`, Math.round(r.made/r.total*100)+'%']);
    }
  });
  
  puttingData.push([]);
  puttingData.push(['HOLE BY HOLE PUTTING']);
  puttingData.push(['Hole', 'First Putt Dist', 'Putts', 'Expected Putts', 'SG Putting']);
  
  allHoles.forEach(h=>{
    if(h.firstPuttDist){
      puttingData.push([
        h.hole,
        h.firstPuttDist + ' ft',
        h.putts,
        h.expectedPutts ? h.expectedPutts.toFixed(2) : 'N/A',
        h.sgPutting ? h.sgPutting.toFixed(2) : 'N/A'
      ]);
    }
  });
  
  const ws5 = XLSX.utils.aoa_to_sheet(puttingData);
  XLSX.utils.book_append_sheet(wb, ws5, 'Putting');
  
  // ============ SHEET 7: PLAY BY PLAY ============
  let playByPlayData = [
    ['PLAY BY PLAY'],
    []
  ];
  
  allHoles.forEach(h=>{
    playByPlayData.push([`Hole ${h.hole}`, `Par ${h.par}`, `${h.yards} yards`]);
    
    h.shots.forEach((s, idx)=>{
      const nextShot = h.shots[idx+1];
      let shotDesc = '';
      let distToHole = '';
      
      // Get distance traveled and end lie
      let endLie = s.lie || 'Unknown';
      if(endLie === 'HOLED') endLie = 'in the hole';
      else if(endLie === 'PUTT') endLie = 'green';
      else if(endLie === 'LEFT ROUGH' || endLie === 'RIGHT ROUGH') endLie = endLie.toLowerCase();
      else if(endLie === 'GS BUNKER' || endLie === 'FW BUNKER') endLie = endLie.toLowerCase().replace('gs ', 'greenside ').replace('fw ', 'fairway ');
      else if(endLie === 'MISS LEFT') endLie = 'left of green';
      else if(endLie === 'MISS RIGHT') endLie = 'right of green';
      else if(endLie === 'MISS SHORT') endLie = 'short of green';
      else if(endLie === 'MISS LONG') endLie = 'long of green';
      else endLie = endLie.toLowerCase();
      
      // Distance of this shot - for tee shots on par 4/5, calculate driving distance
      let shotDist = '';
      if(s.isPutt){
        if(s.distanceBefore != null) shotDist = s.distanceBefore + ' ft';
      } else if(s.shotNum === 1 && (h.par === 4 || h.par === 5) && s.distanceAfter != null){
        // Tee shot on par 4/5 - show driving distance (hole yards - remaining yards)
        const driveDist = h.yards - s.distanceAfter;
        shotDist = driveDist + ' yds';
      } else if(s.shotNum === 1){
        // Tee shot on par 3 - show hole distance
        shotDist = h.yards + ' yds';
      } else if(s.distanceBefore != null){
        shotDist = s.distanceBefore + ' yds';
      }
      
      // Distance remaining
      if(s.lie === 'HOLED'){
        distToHole = '';
        shotDesc = `Shot ${s.shotNum} - ${shotDist} putt, in the hole`;
      } else {
        let remaining = '';
        if(s.distanceAfter != null){
          if(nextShot && nextShot.isPutt){
            remaining = s.distanceAfter + ' ft';
          } else if(s.isPutt){
            remaining = s.distanceAfter + ' ft';
          } else {
            remaining = s.distanceAfter + ' yds';
          }
        } else if(nextShot){
          if(nextShot.isPutt){
            remaining = nextShot.distanceBefore != null ? nextShot.distanceBefore + ' ft' : '';
          } else {
            remaining = nextShot.distanceBefore != null ? nextShot.distanceBefore + ' yds' : '';
          }
        }
        
        if(s.isPutt){
          shotDesc = `Shot ${s.shotNum} - ${shotDist} putt to ${remaining} from hole`;
        } else {
          shotDesc = `Shot ${s.shotNum} - ${shotDist} to ${endLie}, ${remaining} to hole`;
        }
      }
      
      // Format SG for this shot
      let sgDisplay = '';
      if(s.sg != null){
        if(s.sg >= 0){
          sgDisplay = '+' + s.sg.toFixed(2);
        } else {
          sgDisplay = s.sg.toFixed(2);
        }
      }
      
      playByPlayData.push(['', shotDesc, sgDisplay]);
    });
    
    // Add score summary
    const scoreToPar = h.score - h.par;
    let scoreLabel = '';
    if(scoreToPar === -2) scoreLabel = 'Eagle';
    else if(scoreToPar === -1) scoreLabel = 'Birdie';
    else if(scoreToPar === 0) scoreLabel = 'Par';
    else if(scoreToPar === 1) scoreLabel = 'Bogey';
    else if(scoreToPar === 2) scoreLabel = 'Double Bogey';
    else if(scoreToPar > 2) scoreLabel = `+${scoreToPar}`;
    else scoreLabel = `${scoreToPar}`;
    
    playByPlayData.push(['', `Score: ${h.score} (${scoreLabel})`]);
    playByPlayData.push([]);
  });
  
  const ws7 = XLSX.utils.aoa_to_sheet(playByPlayData);
  XLSX.utils.book_append_sheet(wb, ws7, 'Play by Play');
  
  // Helper function to set column widths based on content
  function autoFitColumns(ws, data){
    const colWidths = [];
    data.forEach(row => {
      if(Array.isArray(row)){
        row.forEach((cell, colIdx) => {
          const cellLen = cell ? String(cell).length : 0;
          if(!colWidths[colIdx] || cellLen > colWidths[colIdx]){
            colWidths[colIdx] = cellLen;
          }
        });
      }
    });
    ws['!cols'] = colWidths.map(w => ({ wch: Math.min(Math.max(w + 2, 8), 50) }));
  }
  
  // Set uniform column widths for scorecard
  function setUniformScorecard(ws, numCols){
    const cols = [];
    cols.push({ wch: 8 }); // First column (labels)
    for(let i = 1; i <= numCols; i++){
      cols.push({ wch: 6 }); // Uniform width for hole columns
    }
    ws['!cols'] = cols;
  }
  
  // Helper function to color code SG cells (green for positive, red for negative) with black border
  function colorSGCells(ws, data, sgColIndex, skipParCol = false){
    data.forEach((row, rowIdx) => {
      if(Array.isArray(row) && row[sgColIndex] != null){
        const cellVal = String(row[sgColIndex]);
        // Skip if it's a par value (1-5) and skipParCol is true
        if(skipParCol && ['1','2','3','4','5'].includes(cellVal)) return;
        
        const val = parseFloat(row[sgColIndex]);
        if(!isNaN(val)){
          const cellRef = XLSX.utils.encode_cell({ r: rowIdx, c: sgColIndex });
          if(ws[cellRef]){
            const border = {
              top: { style: 'thin', color: { rgb: '000000' } },
              bottom: { style: 'thin', color: { rgb: '000000' } },
              left: { style: 'thin', color: { rgb: '000000' } },
              right: { style: 'thin', color: { rgb: '000000' } }
            };
            if(val > 0){
              ws[cellRef].s = {
                font: { color: { rgb: "008000" } },
                fill: { fgColor: { rgb: "E8F5E9" } },
                border: border
              };
            } else if(val < 0){
              ws[cellRef].s = {
                font: { color: { rgb: "CC0000" } },
                fill: { fgColor: { rgb: "FFEBEE" } },
                border: border
              };
            } else {
              ws[cellRef].s = { border: border };
            }
          }
        }
      }
    });
  }
  
  // Helper to add borders to a range of cells
  function addBorders(ws, startRow, endRow, startCol, endCol){
    for(let r = startRow; r <= endRow; r++){
      for(let c = startCol; c <= endCol; c++){
        const cellRef = XLSX.utils.encode_cell({ r: r, c: c });
        if(ws[cellRef]){
          ws[cellRef].s = ws[cellRef].s || {};
          ws[cellRef].s.border = {
            top: { style: 'thin', color: { rgb: '000000' } },
            bottom: { style: 'thin', color: { rgb: '000000' } },
            left: { style: 'thin', color: { rgb: '000000' } },
            right: { style: 'thin', color: { rgb: '000000' } }
          };
        }
      }
    }
  }
  
  // Helper to bold cells in a row
  function boldRow(ws, rowIdx, startCol, endCol){
    for(let c = startCol; c <= endCol; c++){
      const cellRef = XLSX.utils.encode_cell({ r: rowIdx, c: c });
      if(ws[cellRef]){
        ws[cellRef].s = ws[cellRef].s || {};
        ws[cellRef].s.font = ws[cellRef].s.font || {};
        ws[cellRef].s.font.bold = true;
      }
    }
  }
  
  // Helper to color score cells relative to par
  function colorScoreVsPar(ws, scoreRowIdx, parRowIdx, startCol, endCol){
    for(let c = startCol; c <= endCol; c++){
      const scoreRef = XLSX.utils.encode_cell({ r: scoreRowIdx, c: c });
      const parRef = XLSX.utils.encode_cell({ r: parRowIdx, c: c });
      if(ws[scoreRef] && ws[parRef]){
        const score = parseInt(ws[scoreRef].v);
        const par = parseInt(ws[parRef].v);
        if(!isNaN(score) && !isNaN(par)){
          const diff = score - par;
          ws[scoreRef].s = ws[scoreRef].s || {};
          ws[scoreRef].s.border = {
            top: { style: 'thin', color: { rgb: '000000' } },
            bottom: { style: 'thin', color: { rgb: '000000' } },
            left: { style: 'thin', color: { rgb: '000000' } },
            right: { style: 'thin', color: { rgb: '000000' } }
          };
          if(diff <= -2){ // Eagle or better
            ws[scoreRef].s.font = { color: { rgb: "FFD700" }, bold: true }; // Gold
            ws[scoreRef].s.fill = { fgColor: { rgb: "FFFDE7" } };
          } else if(diff === -1){ // Birdie
            ws[scoreRef].s.font = { color: { rgb: "008000" } }; // Green
            ws[scoreRef].s.fill = { fgColor: { rgb: "E8F5E9" } };
          } else if(diff === 0){ // Par
            ws[scoreRef].s.font = { color: { rgb: "000000" } };
          } else if(diff === 1){ // Bogey
            ws[scoreRef].s.font = { color: { rgb: "CC0000" } }; // Red
            ws[scoreRef].s.fill = { fgColor: { rgb: "FFEBEE" } };
          } else { // Double+
            ws[scoreRef].s.font = { color: { rgb: "990000" }, bold: true }; // Dark red
            ws[scoreRef].s.fill = { fgColor: { rgb: "FFCDD2" } };
          }
        }
      }
    }
  }
  
  // Apply column widths to all sheets
  autoFitColumns(ws1, scoringData);
  autoFitColumns(wsSG, sgSummaryData);
  autoFitColumns(ws2, teeData);
  autoFitColumns(ws3, approachData);
  autoFitColumns(ws4, shortGameData);
  autoFitColumns(ws5, puttingData);
  autoFitColumns(ws7, playByPlayData);
  
  // Set uniform scorecard column widths
  setUniformScorecard(ws1, Math.max(front9.length + 1, back9.length + 2));
  
  // Apply borders to scorecard on Scoring sheet (rows 8-12 for front 9)
  addBorders(ws1, 8, 12, 0, front9.length + 1);
  // Bold the Par row (row 10) and Header row (row 8)
  boldRow(ws1, 8, 0, front9.length + 1);
  boldRow(ws1, 10, 0, front9.length + 1);
  // Color score cells vs par (score is row 11, par is row 10)
  colorScoreVsPar(ws1, 11, 10, 1, front9.length);
  
  if(back9.length > 0){
    addBorders(ws1, 14, 18, 0, back9.length + 2);
    boldRow(ws1, 14, 0, back9.length + 2);
    boldRow(ws1, 16, 0, back9.length + 2);
    colorScoreVsPar(ws1, 17, 16, 1, back9.length);
  }
  
  // Color code SG summary values at top of Strokes Gained sheet (rows 2-6, column 1)
  colorSGCells(wsSG, sgSummaryData, 1);
  
  // Color code shot-by-shot SG column (column 7) - skip par column coloring
  colorSGCells(wsSG, sgSummaryData, 7, false);
  
  // Bold par values in SG sheet (column 1 starting from row 9)
  sgSummaryData.forEach((row, rowIdx) => {
    if(rowIdx >= 9 && Array.isArray(row) && [3,4,5].includes(row[1])){
      const cellRef = XLSX.utils.encode_cell({ r: rowIdx, c: 1 });
      if(wsSG[cellRef]){
        wsSG[cellRef].s = wsSG[cellRef].s || {};
        wsSG[cellRef].s.font = { bold: true };
        wsSG[cellRef].s.border = {
          top: { style: 'thin', color: { rgb: '000000' } },
          bottom: { style: 'thin', color: { rgb: '000000' } },
          left: { style: 'thin', color: { rgb: '000000' } },
          right: { style: 'thin', color: { rgb: '000000' } }
        };
      }
    }
  });
  
  // Add borders to SG sheet sections
  addBorders(wsSG, 2, 6, 0, 1); // SG summary at top
  addBorders(wsSG, 9, sgSummaryData.length - 1, 0, 7); // Shot data table
  
  // Play by Play - column 2 (SG) - only color SG values, not yardage
  playByPlayData.forEach((row, rowIdx) => {
    if(Array.isArray(row)){
      const cellRef2 = XLSX.utils.encode_cell({ r: rowIdx, c: 2 });
      if(ws7[cellRef2]){
        const val = parseFloat(row[2]);
        if(!isNaN(val)){
          const border = {
            top: { style: 'thin', color: { rgb: '000000' } },
            bottom: { style: 'thin', color: { rgb: '000000' } },
            left: { style: 'thin', color: { rgb: '000000' } },
            right: { style: 'thin', color: { rgb: '000000' } }
          };
          if(val > 0){
            ws7[cellRef2].s = {
              font: { color: { rgb: "008000" } },
              fill: { fgColor: { rgb: "E8F5E9" } },
              border: border
            };
          } else if(val < 0){
            ws7[cellRef2].s = {
              font: { color: { rgb: "CC0000" } },
              fill: { fgColor: { rgb: "FFEBEE" } },
              border: border
            };
          } else {
            ws7[cellRef2].s = { border: border };
          }
        } else {
          // Non-SG cells in column 2 - just border, no color
          ws7[cellRef2].s = {
            border: {
              top: { style: 'thin', color: { rgb: '000000' } },
              bottom: { style: 'thin', color: { rgb: '000000' } },
              left: { style: 'thin', color: { rgb: '000000' } },
              right: { style: 'thin', color: { rgb: '000000' } }
            }
          };
        }
      }
    }
  });
  
  // Add borders to Off The Tee sheet
  addBorders(ws2, 2, 2, 0, 1); // SG row
  addBorders(ws2, 4, 7, 0, 2); // Fairways section with header
  addBorders(ws2, 9, 12, 0, 1); // Driving distance section
  addBorders(ws2, 14, 15 + driveDetails.length, 0, 2); // Driving by hole table
  const penaltyStartRow = 17 + driveDetails.length;
  addBorders(ws2, penaltyStartRow, penaltyStartRow + 2, 0, 1); // Penalties section
  
  // Add borders to Approach sheet
  addBorders(ws3, 2, 2, 0, 1); // SG row
  addBorders(ws3, 4, 5, 0, 2); // GIR section
  addBorders(ws3, 7, 11, 0, 2); // Missed greens
  
  // Add borders to Around the Green sheet
  addBorders(ws4, 2, 2, 0, 1); // SG row
  addBorders(ws4, 4, 5, 0, 2); // Scrambling/Bunkers
  
  // Add borders to Putting sheet - updated for new layout
  addBorders(ws5, 2, 2, 0, 1); // SG row
  addBorders(ws5, 4, 8, 0, 1); // Summary section
  addBorders(ws5, 10, 14, 0, 2); // Performance section
  addBorders(ws5, 16, 17 + puttRanges.filter(r=>r.total>0).length, 0, 2); // Make % by distance
  
  // Color SG values in putting hole-by-hole table
  colorSGCells(ws5, puttingData, 4);
  
  // Create filename from player name, date, course name
  const pName = (playerName.value||'Player').replace(/[^a-zA-Z0-9]/g, '');
  const cName = (courseName.value||'Course').replace(/[^a-zA-Z0-9]/g, '');
  const rDate = formatDateForFilename(roundDate.value);
  const filename = `${pName}_${rDate}_${cName}.xlsx`;
  
  // Save file
  XLSX.writeFile(wb, filename);
}

function generateCSV(){
  let csv='';
  
  // SCORING
  csv+='SCORING\n';
  csv+=`Player:,${playerName.value||'Player'}\n`;
  csv+=`Handicap:,${document.getElementById('playerHandicap').value||'N/A'}\n`;
  csv+=`Course:,${courseName.value||'Course'}\n`;
  csv+=`Date:,${formatDateForDisplay(roundDate.value)}\n`;
  csv+='\n';
  
  csv+='Hole,';
  allHoles.forEach(h=>csv+=`${h.hole},`);
  csv+='TOTAL\n';
  
  csv+='Yards,';
  let totalYards=0;
  allHoles.forEach(h=>{
    csv+=`${h.yards},`;
    totalYards+=h.yards;
  });
  csv+=`${totalYards}\n`;
  
  csv+='Par,';
  allHoles.forEach(h=>csv+=`${h.par},`);
  csv+=`${totalPar}\n`;
  
  csv+='Score,';
  allHoles.forEach(h=>csv+=`${h.score},`);
  csv+=`${totalStrokes}\n`;
  
  csv+='Putts,';
  allHoles.forEach(h=>csv+=`${h.putts},`);
  csv+=`${totalPutts}\n`;
  
  csv+='\n';
  
  csv+=`Avg Par 3 Score,${c3?(p3/c3).toFixed(2):'N/A'}\n`;
  csv+=`Avg Par 4 Score,${c4?(p4/c4).toFixed(2):'N/A'}\n`;
  csv+=`Avg Par 5 Score,${c5?(p5/c5).toFixed(2):'N/A'}\n`;
  csv+='\n';
  
  let eagles=0,birdies=0,pars=0,bogeys=0,doubleOrWorse=0;
  allHoles.forEach(h=>{
    const diff=h.score-h.par;
    if(diff<=-2) eagles++;
    else if(diff===-1) birdies++;
    else if(diff===0) pars++;
    else if(diff===1) bogeys++;
    else doubleOrWorse++;
  });
  csv+=`Eagles,${eagles}\n`;
  csv+=`Birdies,${birdies}\n`;
  csv+=`Pars,${pars}\n`;
  csv+=`Bogeys,${bogeys}\n`;
  csv+=`Double or Worse,${doubleOrWorse}\n`;
  
  // OFF THE TEE
  csv+='\nOFF THE TEE\n';
  csv+=`Fairways Hit,${fwHit}/${fwOpp},${fwOpp?Math.round(fwHit/fwOpp*100):0}%\n`;
  csv+=`Missed Left,${fwLeft},${fwOpp?Math.round(fwLeft/fwOpp*100):0}%\n`;
  csv+=`Missed Right,${fwRight},${fwOpp?Math.round(fwRight/fwOpp*100):0}%\n`;
  
  let drivingDistances=[];
  let driveDetailsCSV=[];
  allHoles.forEach(h=>{
    if((h.par===4||h.par===5)&&h.shots.length>0&&h.shots[0].distanceAfter!=null){
      const driveDistance = h.yards - h.shots[0].distanceAfter;
      drivingDistances.push(driveDistance);
      driveDetailsCSV.push({hole: h.hole, distance: driveDistance, par: h.par, yards: h.yards});
    }
  });
  const avgDrive=drivingDistances.length?Math.round(drivingDistances.reduce((a,b)=>a+b,0)/drivingDistances.length):0;
  csv+=`Avg Driving Distance,${avgDrive} yards\n`;
  csv+='\n';
  csv+='DRIVING DISTANCES\n';
  csv+='Hole,Par,Drive Distance\n';
  driveDetailsCSV.forEach(d=>{
    csv+=`${d.hole},${d.par},${d.distance} yds\n`;
  });
  
  // APPROACH
  csv+='\nAPPROACH\n';
  csv+=`GIR,${gir}/${totalHoles},${totalHoles?Math.round(gir/totalHoles*100):0}%\n`;
  csv+=`Proximity when GIR,${gir?Math.round(girFirstPuttDist/gir):0} ft\n`;
  csv+='\n';
  csv+='MISSED GREENS\n';
  csv+=`Short,${missShort},${girOpp?Math.round(missShort/girOpp*100):0}%\n`;
  csv+=`Long,${missLong},${girOpp?Math.round(missLong/girOpp*100):0}%\n`;
  csv+=`Left,${missLeft},${girOpp?Math.round(missLeft/girOpp*100):0}%\n`;
  csv+=`Right,${missRight},${girOpp?Math.round(missRight/girOpp*100):0}%\n`;
  csv+='\n';
  
  let par3ApproachDist=[],par4ApproachDist=[],par5ApproachDist=[];
  let par3Approaches=[],par4Approaches=[],par5Approaches=[];
  
  allHoles.forEach(h=>{
    h.shots.forEach((s,idx)=>{
      if(!s.isPutt&&s.distanceBefore&&s.lie==='GREEN'){
        if(h.par===3){
          par3ApproachDist.push(s.distanceBefore);
          par3Approaches.push(s.distanceAfter||0);
        }else if(h.par===4){
          par4ApproachDist.push(s.distanceBefore);
          par4Approaches.push(s.distanceAfter||0);
        }else if(h.par===5){
          par5ApproachDist.push(s.distanceBefore);
          par5Approaches.push(s.distanceAfter||0);
        }
      }
    });
  });
  
  const avgPar3Dist=par3ApproachDist.length?Math.round(par3ApproachDist.reduce((a,b)=>a+b,0)/par3ApproachDist.length):0;
  const avgPar3=par3Approaches.length?Math.round(par3Approaches.reduce((a,b)=>a+b,0)/par3Approaches.length):0;
  const avgPar4Dist=par4ApproachDist.length?Math.round(par4ApproachDist.reduce((a,b)=>a+b,0)/par4ApproachDist.length):0;
  const avgPar4=par4Approaches.length?Math.round(par4Approaches.reduce((a,b)=>a+b,0)/par4Approaches.length):0;
  const avgPar5Dist=par5ApproachDist.length?Math.round(par5ApproachDist.reduce((a,b)=>a+b,0)/par5ApproachDist.length):0;
  const avgPar5=par5Approaches.length?Math.round(par5Approaches.reduce((a,b)=>a+b,0)/par5Approaches.length):0;
  
  csv+='Approach by Distance,# of Shots,Avg Proximity\n';
  
  const approachRanges=[
    {min:101,max:125,shots:[],label:'101-125 yards'},
    {min:126,max:150,shots:[],label:'126-150 yards'},
    {min:151,max:175,shots:[],label:'151-175 yards'},
    {min:176,max:200,shots:[],label:'176-200 yards'},
    {min:201,max:225,shots:[],label:'201-225 yards'},
    {min:226,max:250,shots:[],label:'226-250 yards'},
    {min:251,max:275,shots:[],label:'251-275 yards'},
    {min:276,max:999,shots:[],label:'276+ yards'}
  ];
  
  allHoles.forEach(h=>{
    h.shots.forEach((s,idx)=>{
      const distBefore=s.distanceBefore||0;
      if(!s.isPutt&&distBefore>100&&s.lie==='GREEN'){
        approachRanges.forEach(r=>{
          if(distBefore>=r.min&&distBefore<=r.max){
            r.shots.push(s.distanceAfter||0);
          }
        });
      }
    });
  });
  
  approachRanges.forEach(r=>{
    const avg=r.shots.length?Math.round(r.shots.reduce((a,b)=>a+b,0)/r.shots.length):0;
    csv+=`${r.label},${r.shots.length},${avg} ft\n`;
  });
  
  csv+='\n';
  csv+=`Avg Par 3 Tee Shot Distance,${avgPar3Dist} yds,${par3ApproachDist.length} shots\n`;
  csv+=`Avg Par 3 Tee Shot Proximity,${avgPar3} ft\n`;
  csv+='\n';
  csv+=`Avg Par 4 Approach Distance,${avgPar4Dist} yds,${par4ApproachDist.length} shots\n`;
  csv+=`Avg Par 4 Approach Proximity,${avgPar4} ft\n`;
  csv+='\n';
  csv+=`Avg Par 5 Approach Distance,${avgPar5Dist} yds,${par5ApproachDist.length} shots\n`;
  csv+=`Avg Par 5 Approach Proximity,${avgPar5} ft\n`;
  
  // AROUND THE GREEN
  csv+='\nAROUND THE GREEN\n';
  csv+=`Scrambling,${scr}/${scrOpp},${scrOpp?Math.round(scr/scrOpp*100):0}%\n`;
  csv+=`Up & Down from Bunkers,${bun}/${bunOpp},${bunOpp?Math.round(bun/bunOpp*100):0}%\n`;
  
  let bunkerShots=[];
  allHoles.forEach(h=>{
    h.shots.forEach((s,idx)=>{
      if(s.lie&&s.lie.includes('BUNKER')&&h.shots[idx+1]){
        const nextShot=h.shots[idx+1];
        if(nextShot.lie==='GREEN'){
          bunkerShots.push(nextShot.distanceAfter||0);
        }
      }
    });
  });
  const avgBunkerProx=bunkerShots.length?Math.round(bunkerShots.reduce((a,b)=>a+b,0)/bunkerShots.length):0;
  csv+=`Avg Proximity from Bunkers,${avgBunkerProx} ft,${bunkerShots.length} shots\n`;
  csv+='\n';
  csv+='Around the Green by Distance,# of Shots,Avg Proximity\n';
  
  const shortRanges=[
    {min:0,max:25,shots:[],label:'0-25 yards'},
    {min:26,max:50,shots:[],label:'26-50 yards'},
    {min:51,max:75,shots:[],label:'51-75 yards'},
    {min:76,max:100,shots:[],label:'76-100 yards'}
  ];
  
  allHoles.forEach(h=>{
    h.shots.forEach((s,idx)=>{
      const distBefore=s.distanceBefore||0;
      if(!s.isPutt&&distBefore>0&&distBefore<=100&&s.lie==='GREEN'){
        shortRanges.forEach(r=>{
          if(distBefore>=r.min&&distBefore<=r.max){
            r.shots.push(s.distanceAfter||0);
          }
        });
      }
    });
  });
  
  shortRanges.forEach(r=>{
    const avg=r.shots.length?Math.round(r.shots.reduce((a,b)=>a+b,0)/r.shots.length):0;
    csv+=`${r.label},${r.shots.length},${avg} ft\n`;
  });
  
  // PUTTING
  csv+='\nPUTTING\n';
  csv+=`Total Putts,${totalPutts}\n`;
  csv+=`Putts per Hole,${(totalPutts/totalHoles).toFixed(1)}\n`;
  csv+=`Putts per GIR,${gir?(girPutts/gir).toFixed(1):'N/A'}\n`;
  csv+=`Three-Putts,${threePlusPutts}\n`;
  csv+=`One-Putt %,${onePuttOpp?Math.round(onePuttMade/onePuttOpp*100):0}%\n`;
  csv+='\n';
  csv+='STROKES GAINED PUTTING\n';
  csv+=`Total SG Putting,${sgPuttingTotal.toFixed(2)}\n`;
  csv+=`SG Putting per Hole,${(sgPuttingTotal/totalHoles).toFixed(2)}\n`;
  csv+='\n';
  csv+='Hole,First Putt Dist,Putts,Expected Putts,SG Putting\n';
  allHoles.forEach(h=>{
    if(h.firstPuttDist){
      csv+=`${h.hole},${h.firstPuttDist} ft,${h.putts},${h.expectedPutts?h.expectedPutts.toFixed(2):'N/A'},${h.sgPutting?h.sgPutting.toFixed(2):'N/A'}\n`;
    }
  });
  
  // PLAY BY PLAY
  csv+='\nPLAY BY PLAY\n';
  allHoles.forEach(h=>{
    csv+=`\nHole ${h.hole},Par ${h.par},${h.yards} yards\n`;
    
    h.shots.forEach((s, idx)=>{
      const nextShot = h.shots[idx+1];
      let shotDesc = '';
      
      // Get end lie
      let endLie = s.lie || 'Unknown';
      if(endLie === 'HOLED') endLie = 'in the hole';
      else if(endLie === 'PUTT') endLie = 'green';
      else if(endLie === 'LEFT ROUGH' || endLie === 'RIGHT ROUGH') endLie = endLie.toLowerCase();
      else if(endLie === 'GS BUNKER' || endLie === 'FW BUNKER') endLie = endLie.toLowerCase().replace('gs ', 'greenside ').replace('fw ', 'fairway ');
      else if(endLie === 'MISS LEFT') endLie = 'left of green';
      else if(endLie === 'MISS RIGHT') endLie = 'right of green';
      else if(endLie === 'MISS SHORT') endLie = 'short of green';
      else if(endLie === 'MISS LONG') endLie = 'long of green';
      else endLie = endLie.toLowerCase();
      
      // Distance of this shot - for tee shots on par 4/5, calculate driving distance
      let shotDist = '';
      if(s.isPutt){
        if(s.distanceBefore != null) shotDist = s.distanceBefore + ' ft';
      } else if(s.shotNum === 1 && (h.par === 4 || h.par === 5) && s.distanceAfter != null){
        // Tee shot on par 4/5 - show driving distance (hole yards - remaining yards)
        const driveDist = h.yards - s.distanceAfter;
        shotDist = driveDist + ' yds';
      } else if(s.shotNum === 1){
        // Tee shot on par 3 - show hole distance
        shotDist = h.yards + ' yds';
      } else if(s.distanceBefore != null){
        shotDist = s.distanceBefore + ' yds';
      }
      
      // Distance remaining
      if(s.lie === 'HOLED'){
        shotDesc = `Shot ${s.shotNum} - ${shotDist} putt in the hole`;
      } else {
        let remaining = '';
        if(s.distanceAfter != null){
          if(nextShot && nextShot.isPutt){
            remaining = s.distanceAfter + ' ft';
          } else if(s.isPutt){
            remaining = s.distanceAfter + ' ft';
          } else {
            remaining = s.distanceAfter + ' yds';
          }
        } else if(nextShot){
          if(nextShot.isPutt){
            remaining = nextShot.distanceBefore != null ? nextShot.distanceBefore + ' ft' : '';
          } else {
            remaining = nextShot.distanceBefore != null ? nextShot.distanceBefore + ' yds' : '';
          }
        }
        
        if(s.isPutt){
          shotDesc = `Shot ${s.shotNum} - ${shotDist} putt to ${remaining} from hole`;
        } else {
          shotDesc = `Shot ${s.shotNum} - ${shotDist} to ${endLie} - ${remaining} to hole`;
        }
      }
      
      // Format SG for this shot
      let sgDisplay = '';
      if(s.sg != null){
        if(s.sg >= 0){
          sgDisplay = '+' + s.sg.toFixed(2);
        } else {
          sgDisplay = s.sg.toFixed(2);
        }
      }
      
      csv+=`,${shotDesc},${sgDisplay}\n`;
    });
    
    // Score summary
    const scoreToPar = h.score - h.par;
    let scoreLabel = '';
    if(scoreToPar === -2) scoreLabel = 'Eagle';
    else if(scoreToPar === -1) scoreLabel = 'Birdie';
    else if(scoreToPar === 0) scoreLabel = 'Par';
    else if(scoreToPar === 1) scoreLabel = 'Bogey';
    else if(scoreToPar === 2) scoreLabel = 'Double Bogey';
    else if(scoreToPar > 2) scoreLabel = '+' + scoreToPar;
    else scoreLabel = scoreToPar.toString();
    
    csv+=`,Score: ${h.score} (${scoreLabel})\n`;
  });
  
  // STROKES GAINED DATA
  csv+='\n\nSTROKES GAINED DATA\n';
  csv+='Hole,Par,Shot #,Start Distance,Start Lie,End Lie,End Distance\n';
  
  function categorizeLieCSV(lie, isPutt, isFromTee){
    if(isFromTee) return 'Tee';
    if(isPutt || lie === 'GREEN' || lie === 'PUTT') return 'Green';
    if(lie === 'FAIRWAY') return 'Fairway';
    if(lie === 'LEFT ROUGH' || lie === 'RIGHT ROUGH') return 'Rough';
    if(lie === 'MISS LEFT' || lie === 'MISS RIGHT' || lie === 'MISS SHORT' || lie === 'MISS LONG') return 'Rough';
    if(lie === 'GS BUNKER' || lie === 'FW BUNKER') return 'Sand';
    if(lie === 'RECOVERY' || lie === 'PENALTY' || lie === 'OB' || lie === 'WATER') return 'Recovery';
    return 'Rough';
  }
  
  allHoles.forEach(h=>{
    h.shots.forEach((s, idx)=>{
      const nextShot = h.shots[idx+1];
      const prevShot = idx > 0 ? h.shots[idx-1] : null;
      
      // Start lie category
      let startLieCat = '';
      if(s.shotNum === 1){
        startLieCat = 'Tee';
      } else if(s.isPutt){
        startLieCat = 'Green';
      } else if(prevShot && prevShot.lie){
        startLieCat = categorizeLieCSV(prevShot.lie, false, false);
      } else {
        startLieCat = 'Unknown';
      }
      
      // Start distance - yards off green, feet on green
      let startDist = s.distanceBefore || 0;
      let startDistDisplay = '';
      if(s.isPutt){
        startDistDisplay = startDist + ' ft';
      } else {
        startDistDisplay = startDist + ' yds';
      }
      
      // End lie category
      let endLieCat = '';
      if(s.lie === 'HOLED'){
        endLieCat = 'Holed';
      } else {
        endLieCat = categorizeLieCSV(s.lie, s.isPutt, false);
      }
      
      // End distance - yards off green, feet on green
      let endDistDisplay = '0';
      if(s.lie === 'HOLED'){
        endDistDisplay = '0';
      } else if(s.distanceAfter != null){
        if(nextShot && nextShot.isPutt){
          endDistDisplay = s.distanceAfter + ' ft';
        } else if(s.isPutt){
          endDistDisplay = s.distanceAfter + ' ft';
        } else {
          endDistDisplay = s.distanceAfter + ' yds';
        }
      } else if(nextShot){
        if(nextShot.isPutt){
          endDistDisplay = (nextShot.distanceBefore || 0) + ' ft';
        } else {
          endDistDisplay = (nextShot.distanceBefore || 0) + ' yds';
        }
      }
      
      csv+=`${h.hole},${h.par},${s.shotNum},${startDistDisplay},${startLieCat},${endLieCat},${endDistDisplay}\n`;
    });
  });
  
  return csv;
}

// Handle mobile keyboard - scroll focused input into view
document.addEventListener('focusin', function(e) {
  if(e.target.tagName === 'INPUT') {
    setTimeout(() => {
      e.target.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }, 300);
  }
});

// Reset scroll position when page changes
const originalShow = show;
show = function(id) {
  originalShow(id);
  const page = document.getElementById(id);
  if(page) {
    page.scrollTop = 0;
  }
  window.scrollTo(0, 0);
};
</script>

</body>
</html>
